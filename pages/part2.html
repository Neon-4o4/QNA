<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   CSE 1287 QnA Solution
  </title>
  <script src="https://cdn.tailwindcss.com">
  </script>
  <link href="../style.css" rel="stylesheet"/>
 </head>
 <body class="bg-gray-100 font-sans">
  <!-- Sidebar -->
  <aside class="bg-gray-800 text-white w-64 min-h-screen p-4 fixed md:relative transform -translate-x-full md:translate-x-0 transition-transform duration-200 ease-in-out" id="sidebar">
   <nav>
    <ul>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700" href="part1.html">
       Part I: Computer Fundamentals
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="core-computer-organization.html">
       a. Core Computer Organization
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="storage-and-memory.html">
       b. Storage and Memory
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="number-systems.html">
       c. Number Systems
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="algorithms-and-flowcharts.html">
       d. Algorithms and Flowcharts
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="programming-language-levels.html">
       e. Programming Language Levels
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="language-translators.html">
       f. Language Translators
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="operating-systems-overview.html">
       g. Operating Systems Overview
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700" href="part2.html">
       Part II: Programming with C/C++
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="preliminaries.html">
       a. Preliminaries
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="io-statements.html">
       b. I/O Statements
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="expressions-and-operators.html">
       c. Expressions and Operators
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="decision-making.html">
       d. Decision Making
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="loops.html">
       e. Loops
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="functions-and-calling-procedures.html">
       f. Functions
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="recursion.html">
       g. Recursion
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="arrays-and-pointers.html">
       h. Arrays and Pointers
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="structure-and-union.html">
       i. Structure and Union
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="applications-in-mechatronics-engineering.html">
       j. Applications in Mechatronics
      </a>
     </li>
    </ul>
   </nav>
  </aside>
  <div class="flex flex-col flex-1">
   <header class="bg-white shadow-md p-4 flex justify-between items-center">
    <button class="md:hidden" id="sidebar-toggle">
     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      </path>
     </svg>
    </button>
    <h1 class="text-xl font-semibold">
     CSE 1287 QnA (Year 2014-2023) - Solution
    </h1>
    <p>
     Generated By: Mahmud | 2308009
    </p>
   </header>
   <main class="p-8">
    <section id="part2">
     <h2>
      Part II: Programming with C/C++ Language
     </h2>
     <section id="preliminaries">
      <h3>
       a. Preliminaries, Program Construction, and Data Types
      </h3>
      <article>
       <h4>
        1. List out the fundamental data types with their range which are used in C. / Describe the data types. List all C data types with bit limitations and memory requirements.
       </h4>
       <p>
        Fundamental data types in C define the type and size of data a variable can hold. The exact size and range can vary by system architecture (e.g., 16-bit vs 64-bit), but typical values are shown below.
       </p>
       <table>
        <thead>
         <tr>
          <th>
           Data Type
          </th>
          <th>
           Typical Size (bytes)
          </th>
          <th>
           Typical Range
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           char
          </td>
          <td>
           1
          </td>
          <td>
           -128 to 127 or 0 to 255
          </td>
         </tr>
         <tr>
          <td>
           unsigned char
          </td>
          <td>
           1
          </td>
          <td>
           0 to 255
          </td>
         </tr>
         <tr>
          <td>
           short int
          </td>
          <td>
           2
          </td>
          <td>
           -32,768 to 32,767
          </td>
         </tr>
         <tr>
          <td>
           unsigned short int
          </td>
          <td>
           2
          </td>
          <td>
           0 to 65,535
          </td>
         </tr>
         <tr>
          <td>
           int
          </td>
          <td>
           4
          </td>
          <td>
           -2,147,483,648 to 2,147,483,647
          </td>
         </tr>
         <tr>
          <td>
           unsigned int
          </td>
          <td>
           4
          </td>
          <td>
           0 to 4,294,967,295
          </td>
         </tr>
         <tr>
          <td>
           long int
          </td>
          <td>
           4 or 8
          </td>
          <td>
           Varies, typically same as int or long long int
          </td>
         </tr>
         <tr>
          <td>
           unsigned long int
          </td>
          <td>
           4 or 8
          </td>
          <td>
           Varies, typically same as unsigned int or unsigned long long int
          </td>
         </tr>
         <tr>
          <td>
           long long int
          </td>
          <td>
           8
          </td>
          <td>
           -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
          </td>
         </tr>
         <tr>
          <td>
           unsigned long long int
          </td>
          <td>
           8
          </td>
          <td>
           0 to 18,446,744,073,709,551,615
          </td>
         </tr>
         <tr>
          <td>
           float
          </td>
          <td>
           4
          </td>
          <td>
           Approx. 1.2E-38 to 3.4E+38 (6-7 decimal digits precision)
          </td>
         </tr>
         <tr>
          <td>
           double
          </td>
          <td>
           8
          </td>
          <td>
           Approx. 2.3E-308 to 1.7E+308 (15-16 decimal digits precision)
          </td>
         </tr>
         <tr>
          <td>
           long double
          </td>
          <td>
           10, 12, or 16
          </td>
          <td>
           Higher precision and range than double
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        2. Define keyword and Identifier in C programming. / What is identifier? Find the valid and invalid identifiers from the following: mte. mte16, @ruet, MTE-ruet. / Write the rules of naming identifier of C programming language.
       </h4>
       <ul>
        <li>
         <strong>
          Keyword:
         </strong>
         A keyword is a reserved word that has a predefined meaning and purpose in the C language. These words cannot be used as variable names or identifiers. Examples include int, if, else, while, return.
        </li>
        <li>
         <strong>
          Identifier:
         </strong>
         An identifier is a user-defined name given to a variable, function, structure, or other programming entity. It is used to uniquely identify that entity in the program.
        </li>
       </ul>
       <h5>
        Rules for Naming Identifiers:
       </h5>
       <ol>
        <li>
         An identifier can only contain alphanumeric characters (a-z, A-Z, 0-9) and the underscore character (_).
        </li>
        <li>
         The first character of an identifier must be an alphabet (a-z, A-Z) or an underscore (_). It cannot start with a digit.
        </li>
        <li>
         Keywords cannot be used as identifiers.
        </li>
        <li>
         Identifiers are case-sensitive (e.g., myVar and myvar are different).
        </li>
        <li>
         There is no rule on the length of an identifier, but only the first 31 characters are significant to some compilers.
        </li>
       </ol>
       <h5>
        Validation of given identifiers:
       </h5>
       <ul>
        <li>
         mte:
         <strong>
          Valid
         </strong>
         . Starts with a letter, contains only letters.
        </li>
        <li>
         mte16:
         <strong>
          Valid
         </strong>
         . Starts with a letter, contains letters and digits.
        </li>
        <li>
         @ruet:
         <strong>
          Invalid
         </strong>
         . Contains a special character (@) which is not allowed.
        </li>
        <li>
         MTE-ruet:
         <strong>
          Invalid
         </strong>
         . Contains a hyphen (-) which is not allowed.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. Define C tokens with example.
       </h4>
       <p>
        A C token is the smallest individual unit in a C program that is meaningful to the compiler. The C compiler breaks a program down into tokens during the lexical analysis phase.
       </p>
       <p>
        The types of C tokens are:
       </p>
       <ol>
        <li>
         <strong>
          Keywords:
         </strong>
         Reserved words with special meanings (e.g., if, float, for).
        </li>
        <li>
         <strong>
          Identifiers:
         </strong>
         User-defined names for variables, functions, etc. (e.g., main, age, calculateSum).
        </li>
        <li>
         <strong>
          Constants:
         </strong>
         Fixed values that do not change (e.g., 10, 3.14, 'A').
        </li>
        <li>
         <strong>
          String Literals:
         </strong>
         A sequence of characters enclosed in double quotes (e.g., "Hello, World!").
        </li>
        <li>
         <strong>
          Operators:
         </strong>
         Symbols that perform operations (e.g., +, =, ==, &amp;&amp;).
        </li>
        <li>
         <strong>
          Special Symbols:
         </strong>
         Characters with special meanings, like punctuators (e.g., ;, {, }, ()).
        </li>
       </ol>
      </article>
      <article>
       <h4>
        4. What is the difference between variable declaration and variable definition? / What do you mean by declaration and definition of a variable?
       </h4>
       <ul>
        <li>
         <strong>
          Declaration:
         </strong>
         A declaration introduces a variable's name and type to the compiler. It tells the compiler about the existence of a variable but does not allocate memory for it. A declaration is often used when a variable is defined in another file, using the extern keyword. A variable can be declared multiple times.
         <ul>
          <li>
           Example: extern int count;
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Definition:
         </strong>
         A definition is a declaration that also allocates storage space for the variable. It is where the variable is created. A variable can be defined only once in a program. Most simple variable statements are definitions.
         <ul>
          <li>
           Example: int count; or int count = 10;
          </li>
         </ul>
        </li>
       </ul>
       <p>
        In C, a statement like int x; inside a function is a definition because it allocates memory on the stack. At the file scope, int x; is a "tentative definition" which becomes a full definition if no other definition is found.
       </p>
      </article>
      <article>
       <h4>
        5. Find errors, if any, in the following declaration statements: Int x; float letter, DIGIT; double exponent alpha, beta; m,n,z: INTEGER; short char c; long int m; count; long float temp; int ROW TOTAL:; Float 3:.
       </h4>
       <ul>
        <li>
         Int x;:
         <strong>
          Error
         </strong>
         . Int should be int (C is case-sensitive).
        </li>
        <li>
         float letter, DIGIT;:
         <strong>
          Valid
         </strong>
         .
        </li>
        <li>
         double $=p,q$:
         <strong>
          Error
         </strong>
         . $ is not a valid character for an identifier name.
        </li>
        <li>
         exponent alpha, beta;:
         <strong>
          Error
         </strong>
         . The data type is missing (e.g., float exponent, alpha, beta;).
        </li>
        <li>
         m,n,z: INTEGER;:
         <strong>
          Error
         </strong>
         . C uses the format type name;, not name: TYPE;. Also, INTEGER is not a standard C type. It should be int m, n, z;.
        </li>
        <li>
         short char c;:
         <strong>
          Error
         </strong>
         . short cannot be used to modify char. It can modify int.
        </li>
        <li>
         long int m;:
         <strong>
          Valid
         </strong>
         .
        </li>
        <li>
         count;:
         <strong>
          Error
         </strong>
         . The data type is missing (e.g., int count;).
        </li>
        <li>
         long float temp;:
         <strong>
          Error
         </strong>
         . long cannot be used to modify float. Use double or long double.
        </li>
        <li>
         int ROW TOTAL:;:
         <strong>
          Error
         </strong>
         . Identifier ROW TOTAL contains a space, and there is an extraneous colon. It should be int ROW_TOTAL;.
        </li>
        <li>
         Float 3:;:
         <strong>
          Error
         </strong>
         . Float should be float, and 3 is not a valid identifier name.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        6. Distinguish between the following two statements: int varl; and const int var1;.
       </h4>
       <ul>
        <li>
         int var1;: This statement
         <strong>
          defines
         </strong>
         a variable named var1 of type int. The value of var1 is mutable, meaning it can be changed at any point in the program after its definition.
        </li>
        <li>
         const int var1;: This statement defines a
         <strong>
          constant
         </strong>
         variable named var1 of type int. The const qualifier makes the variable read-only. Its value must be initialized at the time of definition (e.g., const int var1 = 10;), and any attempt to modify it later in the program will result in a compilation error.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        7. What is the difference between the following expressions: #define max 52 and const int max 52;.
       </h4>
       <ul>
        <li>
         #define max 52: This is a
         <strong>
          preprocessor directive
         </strong>
         . Before compilation, the preprocessor scans the code and replaces every occurrence of the token max with the text 52. This is a simple text substitution. #define macros have no data type and do not respect scope rules.
        </li>
        <li>
         const int max = 52;: This is a
         <strong>
          variable definition
         </strong>
         . It creates a read-only variable named max of type int with the value 52. This variable has a type, exists in memory, and follows standard scope rules (it is only visible within the block it is defined in). Using const is generally preferred in modern C/C++ as it is type-safe and provides better debugging information.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        8. Define type casting in C. Explain the basic data types of C.
       </h4>
       <h5>
        Type Casting:
       </h5>
       <p>
        Type casting is the process of explicitly converting a value from one data type to another. It is done by placing the desired data type in parentheses before the variable or value to be converted. This is often used to force a certain type of arithmetic or to avoid compiler warnings.
       </p>
       <ul>
        <li>
         <strong>
          Example:
         </strong>
         <pre><code>
int a = 10, b = 4;
float result = (float)a / b; // result will be 2.5
// Without the cast, integer division would occur, and the result would be 2.0
                            </code></pre>
        </li>
       </ul>
       <h5>
        Basic Data Types of C:
       </h5>
       <p>
        (See answer to question 1 in this section for a detailed list and description). The basic types are char (for characters), int (for integers), float (for single-precision floating-point numbers), and double (for double-precision floating-point numbers). These can be modified by qualifiers like short, long, signed, and unsigned.
       </p>
      </article>
     </section>
     <section id="io-statements">
      <h3>
       b. Input/Output (I/O) Statements
      </h3>
      <article>
       <h4>
        1. State the limitation of using scanf function for reading strings. How can you overcome it?
       </h4>
       <p>
        The primary limitation of using scanf("%s", str); for reading strings is that it
        <strong>
         stops reading at the first whitespace character
        </strong>
        (space, tab, or newline). This makes it unsuitable for reading strings that contain spaces, such as a full name or a sentence.
       </p>
       <p>
        This limitation can be overcome in several ways:
       </p>
       <ol>
        <li>
         <strong>
          Using fgets():
         </strong>
         This is the recommended and safest method. fgets(str, size, stdin); reads an entire line of input, including spaces, until a newline character is read or the specified size limit is reached. It also prevents buffer overflows.
        </li>
        <li>
         <strong>
          Using scanf with a modified format specifier:
         </strong>
         You can use scanf("%[^\n]s", str);. This tells scanf to read all characters until a newline (\n) is encountered. However, this method is still risky as it does not have built-in protection against buffer overflows.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        2. What is the significance of gets and puts function?
       </h4>
       <ul>
        <li>
         gets(char *str): The purpose of gets() is to read a line of text from the standard input (stdin) and store it in the string str. It reads characters until a newline character is encountered, which is then discarded.
         <ul>
          <li>
           <strong>
            Significance/Warning:
           </strong>
           While simple to use, gets() is
           <strong>
            extremely dangerous and has been deprecated
           </strong>
           . It performs no bounds checking, meaning it will continue to write past the end of the buffer if the input is too long, leading to buffer overflow vulnerabilities. It should
           <strong>
            never
           </strong>
           be used in modern code.
          </li>
         </ul>
        </li>
        <li>
         puts(const char *str): The purpose of puts() is to write a string to the standard output (stdout).
         <ul>
          <li>
           <strong>
            Significance:
           </strong>
           It is a simple and efficient way to print a string. After printing the entire string, puts() automatically appends a newline character (\n) to the output, which is often convenient.
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. Distinguish between the following terms i) printf and printf.
       </h4>
       <ul>
        <li>
         printf: The printf function writes formatted output to the
         <strong>
          standard output stream (stdout)
         </strong>
         , which is typically the console or terminal screen.
         <ul>
          <li>
           <strong>
            Syntax:
           </strong>
           int printf(const char *format,...);
          </li>
          <li>
           <strong>
            Usage:
           </strong>
           Used for general output to the user.
          </li>
         </ul>
        </li>
        <li>
         printf: The printf function writes formatted output to a
         <strong>
          specified file stream
         </strong>
         . This stream could be a file on the disk, or standard streams like stdout or stderr (standard error).
         <ul>
          <li>
           <strong>
            Syntax:
           </strong>
           int printf(FILE *stream, const char *format,...);
          </li>
          <li>
           <strong>
            Usage:
           </strong>
           Used for writing to files or for directing output to specific streams, such as sending error messages to stderr instead of stdout. printf(...) is functionally equivalent to printf(stdout,...).
          </li>
         </ul>
        </li>
       </ul>
      </article>
     </section>
     <section id="expressions-and-operators">
      <h3>
       c. Expressions and Operators
      </h3>
      <article>
       <h4>
        1. What is binary and unary operator in C? Explain with examples.
       </h4>
       <ul>
        <li>
         <strong>
          Unary Operator:
         </strong>
         A unary operator is an operator that works on a single operand.
         <ul>
          <li>
           <strong>
            Examples:
           </strong>
           <ul>
            <li>
             ++ (Increment): ++i; (increments the value of i by 1)
            </li>
            <li>
             -- (Decrement): --i; (decrements the value of i by 1)
            </li>
            <li>
             - (Unary Minus): -x; (negates the value of x)
            </li>
            <li>
             ! (Logical NOT): !flag; (inverts the boolean value of flag)
            </li>
            <li>
             sizeof (Sizeof): sizeof(int); (returns the size of the int type)
            </li>
           </ul>
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Binary Operator:
         </strong>
         A binary operator is an operator that works on two operands. Most operators in C are binary.
         <ul>
          <li>
           <strong>
            Examples:
           </strong>
           <ul>
            <li>
             + (Addition): a + b;
            </li>
            <li>
             * (Multiplication): x * y;
            </li>
            <li>
             &gt; (Greater Than): a &gt; b;
            </li>
            <li>
             &amp;&amp; (Logical AND): (x &gt; 0) &amp;&amp; (y &gt; 0);
            </li>
            <li>
             = (Assignment): a = 5;
            </li>
           </ul>
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        2. What is a conditional operator? Can you use conditional operator in place of if...else statement? Show logic behind your answer.
       </h4>
       <p>
        The conditional operator, also known as the ternary operator, is a unique operator in C that takes three operands. Its syntax is:
        <br/>
        condition? expression_if_true : expression_if_false;
       </p>
       <p>
        Yes, the conditional operator can be used in place of a simple if...else statement, particularly for assignments.
       </p>
       <h5>
        Logic:
       </h5>
       <p>
        The condition is evaluated first.
       </p>
       <ul>
        <li>
         If the condition is true (non-zero), expression_if_true is evaluated, and its result becomes the result of the entire expression.
        </li>
        <li>
         If the condition is false (zero), expression_if_false is evaluated, and its result becomes the result of the entire expression.
        </li>
       </ul>
       <h5>
        Example:
       </h5>
       <p>
        Consider the following if...else statement:
       </p>
       <pre><code>
if (x &gt; y) {
    max = x;
} else {
    max = y;
}
                    </code></pre>
       <p>
        This is logically equivalent to the following statement using the conditional operator:
       </p>
       <pre><code>
max = (x &gt; y)? x : y;
                    </code></pre>
       <p>
        Both achieve the same result: assigning the larger of x and y to the variable max.
       </p>
      </article>
      <article>
       <h4>
        3. Distinguish between the following terms: ii) and iii) "==" and "=" argument.
       </h4>
       <h5>
        ii) a = i++ (Post-increment) vs. a = ++i (Pre-increment)
       </h5>
       <ul>
        <li>
         a = i++; (Post-increment): First, the current value of i is assigned to a.
         <strong>
          Then
         </strong>
         , the value of i is incremented by 1.
         <ul>
          <li>
           Example: If i is 5, a becomes 5, and i becomes 6.
          </li>
         </ul>
        </li>
        <li>
         a = ++i; (Pre-increment): First, the value of i is incremented by 1.
         <strong>
          Then
         </strong>
         , the new (incremented) value of i is assigned to a.
         <ul>
          <li>
           Example: If i is 5, i becomes 6, and a also becomes 6.
          </li>
         </ul>
        </li>
       </ul>
       <h5>
        iii) == (Equality Operator) vs. = (Assignment Operator)
       </h5>
       <ul>
        <li>
         == (Equality Operator): This is a
         <strong>
          comparison
         </strong>
         operator. It checks if the values of its two operands are equal. It returns a boolean result: 1 (true) if they are equal, and 0 (false) if they are not.
         <ul>
          <li>
           Example: if (x == 10) checks if the value of x is equal to 10.
          </li>
         </ul>
        </li>
        <li>
         = (Assignment Operator): This is an
         <strong>
          assignment
         </strong>
         operator. It assigns the value of the right-hand operand to the left-hand operand.
         <ul>
          <li>
           Example: x = 10; assigns the value 10 to the variable x.
          </li>
         </ul>
        </li>
       </ul>
       <p>
        A common programming error is to use = in a condition where == was intended.
       </p>
      </article>
      <article>
       <h4>
        4. Suppose the value of a is 5 and b is 6; what will be the value of a and b after execution of following statements? a++; b; .
       </h4>
       <p>
        Let's trace the execution step-by-step.
        <br/>
        Initial values: a = 5, b = 6.
       </p>
       <ol>
        <li>
         a++;
         <ul>
          <li>
           This is a post-increment. The value of a becomes 6.
          </li>
          <li>
           Current state: a = 6, b = 6.
          </li>
         </ul>
        </li>
        <li>
         b;
         <ul>
          <li>
           This is a statement with no effect. It simply accesses the value of b and does nothing with it.
          </li>
          <li>
           Current state: a = 6, b = 6.
          </li>
         </ul>
        </li>
        <li>
         b = (-b) + (b--) + a;
         <ul>
          <li>
           This expression has undefined behavior in C because b is modified (b--) and also read (-b) in the same expression without a sequence point. The order of evaluation of (-b) and (b--) is not guaranteed.
          </li>
          <li>
           <strong>
            However, if we assume a common left-to-right evaluation for the terms:
           </strong>
           <ul>
            <li>
             (-b): The current value of b is 6, so this evaluates to -6.
            </li>
            <li>
             (b--): This is a post-decrement. The current value of b (which is 6) is used in the expression. After its value is used, b is decremented to 5.
            </li>
            <li>
             a: The current value of a is 6.
            </li>
            <li>
             The expression becomes: b = (-6) + (6) + 6;
            </li>
            <li>
             b = 0 + 6;
            </li>
            <li>
             b = 6;
            </li>
           </ul>
          </li>
          <li>
           The final value of b from the decrement (b--) is 5, but this is immediately overwritten by the assignment.
          </li>
         </ul>
        </li>
       </ol>
       <p>
        <strong>
         Final values (assuming one possible evaluation order):
        </strong>
       </p>
       <ul>
        <li>
         a = 6
        </li>
        <li>
         b = 6
        </li>
       </ul>
      </article>
      <article>
       <h4>
        5. Find the value of s, p and r if and. (i) (ii) (iii).
       </h4>
       <p>
        (Note: The expressions are missing. This answer provides a template for solving such problems.)
       </p>
       <p>
        To solve expressions involving operator precedence and associativity, follow these steps:
       </p>
       <ol>
        <li>
         Identify all operators in the expression.
        </li>
        <li>
         Follow the C operator precedence rules to determine the order of evaluation (e.g., *, /, % before +, -).
        </li>
        <li>
         If operators have the same precedence, use their associativity rules (e.g., +, -, *, / are left-to-right associative).
        </li>
        <li>
         Evaluate the expression step-by-step, substituting values as you go.
        </li>
       </ol>
       <h5>
        Example: r = 5 + 3 * 2;
       </h5>
       <ol>
        <li>
         Operators are + and *.
        </li>
        <li>
         * has higher precedence than +.
        </li>
        <li>
         Evaluate 3 * 2 first, which is 6.
        </li>
        <li>
         The expression becomes r = 5 + 6;.
        </li>
        <li>
         Evaluate 5 + 6, which is 11.
        </li>
        <li>
         r becomes 11.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        6. Determine the value of each expression: (i) (ii).
       </h4>
       <p>
        (Note: The expressions are missing. See the method outlined in the answer to question 5 above.)
       </p>
      </article>
     </section>
     <section id="decision-making">
      <h3>
       d. Decision Making
      </h3>
      <article>
       <h4>
        1. What is the purpose of the switch statement? How does it differ from the 'if-else' statement?
       </h4>
       <p>
        The purpose of the switch statement is to provide a multi-way branching capability. It allows a program to execute different blocks of code based on the value of a single variable or expression. It serves as a more readable and often more efficient alternative to a long series of if-else if-else statements.
       </p>
       <h5>
        Differences from if-else:
       </h5>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           switch Statement
          </th>
          <th>
           if-else Statement
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Condition
           </strong>
          </td>
          <td>
           Tests a variable against a set of discrete integer or character constant values (case labels).
          </td>
          <td>
           Can evaluate complex relational and logical expressions (e.g., x &gt; 10 &amp;&amp; y &lt; 20).
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Data Types
           </strong>
          </td>
          <td>
           Can only test for equality on integral types (int, char).
          </td>
          <td>
           Can handle any type of expression that results in a true (non-zero) or false (zero) value, including ranges and floating-point numbers.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Flexibility
           </strong>
          </td>
          <td>
           Less flexible; limited to equality checks on a single variable.
          </td>
          <td>
           Highly flexible; can compare different variables and use various operators.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Readability
           </strong>
          </td>
          <td>
           More readable and cleaner for a large number of fixed choices.
          </td>
          <td>
           Can become nested and hard to read if there are many conditions ("if-else ladder").
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            "Fall- through"
           </strong>
          </td>
          <td>
           Has a "fall-through" behavior where execution continues to the next case unless a break statement is used.
          </td>
          <td>
           Each if or else block is a distinct, isolated scope.
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        2. Write a C program that read a mark and display its grade using switch statement.
       </h4>
       <pre><code>
#include <stdio.h>

int main() {
    int mark;
    char grade;

    printf("Enter the mark (0-100): ");
    scanf("%d", &amp;mark);

    // To use switch, we can categorize the mark by dividing by 10.
    // This converts the range into discrete integer values.
    switch (mark / 10) {
        case 10:
        case 9:
        case 8:
            grade = 'A';
            break;
        case 7:
            grade = 'B';
            break;
        case 6:
            grade = 'C';
            break;
        case 5:
            grade = 'D';
            break;
        default: // For marks 0-49
            grade = 'F';
            break;
    }

    // Handle invalid input
    if (mark &lt; 0 || mark &gt; 100) {
        printf("Invalid mark entered.\\n");
    } else {
        printf("The grade is: %c\\n", grade);
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        3. Define loop control statements. Is a 'break' required by 'default' case in switch statement? Justify your answer.
       </h4>
       <p>
        <strong>
         Loop control statements
        </strong>
        are statements that alter the normal, sequential flow of execution within a loop. They are used to terminate a loop prematurely or to skip an iteration. The main loop control statements in C are:
       </p>
       <ul>
        <li>
         break: Immediately terminates the innermost loop or switch statement in which it appears.
        </li>
        <li>
         continue: Skips the remaining code in the current iteration of a loop and proceeds to the next iteration.
        </li>
        <li>
         goto: Unconditionally transfers control to a labeled statement (its use is highly discouraged).
        </li>
       </ul>
       <h5>
        Is break required in the default case?
       </h5>
       <p>
        No, a break statement is not syntactically required for the default case if it is the last case in the switch block.
       </p>
       <h5>
        Justification:
       </h5>
       <p>
        The switch statement executes code until it encounters a break statement or until the end of the switch block is reached. If the default case is the very last one, after its code is executed, control will naturally fall out of the switch block anyway. Therefore, a break is redundant.
        <br/>
        However, it is considered
        <strong>
         good programming practice
        </strong>
        to include a break in the default case. This prevents accidental "fall-through" errors if another case is added after the default case in the future.
       </p>
      </article>
     </section>
     <section id="loops">
      <h3>
       e. Loops
      </h3>
      <article>
       <h4>
        1. Differentiate between while and do-while loop in C. / How does while loop differ from a 'do... while loop? Briefly explain with suitable examples. / Write down the difference between following terms: While and do-while statement.
       </h4>
       <p>
        The primary difference between a while loop and a do-while loop is when the loop condition is checked.
       </p>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           while Loop
          </th>
          <th>
           do-while Loop
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Control Type
           </strong>
          </td>
          <td>
           <strong>
            Entry-Controlled Loop
           </strong>
           or
           <strong>
            Pre-test Loop
           </strong>
           .
          </td>
          <td>
           <strong>
            Exit-Controlled Loop
           </strong>
           or
           <strong>
            Post-test Loop
           </strong>
           .
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Condition Check
           </strong>
          </td>
          <td>
           The condition is checked
           <strong>
            before
           </strong>
           executing the loop body.
          </td>
          <td>
           The condition is checked
           <strong>
            after
           </strong>
           executing the loop body.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Minimum Executions
           </strong>
          </td>
          <td>
           <strong>
            Zero or more times.
           </strong>
           If the condition is initially false, the loop body never executes.
          </td>
          <td>
           <strong>
            One or more times.
           </strong>
           The loop body is guaranteed to execute at least once.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Syntax
           </strong>
          </td>
          <td>
           while (condition) { // body }
          </td>
          <td>
           do { // body } while (condition);
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Semicolon Usage
           </strong>
          </td>
          <td>
           No semicolon after the while (condition).
          </td>
          <td>
           A semicolon is required after the while (condition).
          </td>
         </tr>
        </tbody>
       </table>
       <h5>
        Example while loop:
       </h5>
       <pre><code>
int i = 5;
while (i &lt; 5) {
    printf("This will not be printed.\\n"); // Body does not execute
    i++;
}
                    </code></pre>
       <h5>
        Example do-while loop:
       </h5>
       <pre><code>
int i = 5;
do {
    printf("This will be printed once.\\n"); // Body executes once
    i++;
} while (i &lt; 5);
                    </code></pre>
      </article>
      <article>
       <h4>
        2. Give example and application where "while" loop is better than "do while" loop. / In which situation you will prefer do-while loop over for or while loop? Justify your answer.
       </h4>
       <p>
        A
        <strong>
         while loop
        </strong>
        is better when you need to check a condition
        <em>
         before
        </em>
        performing any action, and it's possible that the action should not be performed at all.
       </p>
       <ul>
        <li>
         <strong>
          Application:
         </strong>
         Reading from a file. You should check if you have reached the end of the file
         <em>
          before
         </em>
         attempting to read the next line.
         <pre><code>
while (fgets(buffer, sizeof(buffer), file) != NULL) {
    // Process the line in the buffer
}
                            </code></pre>
        </li>
       </ul>
       <p>
        You would prefer a
        <strong>
         do-while loop
        </strong>
        when the loop body must execute at least once, regardless of the condition.
       </p>
       <ul>
        <li>
         <strong>
          Justification:
         </strong>
         This pattern is common in situations that require an initial action before a condition can be tested.
        </li>
        <li>
         <strong>
          Application:
         </strong>
         A menu-driven program or user input validation. You must first display the menu or prompt for input
         <em>
          at least once
         </em>
         before you can check if the user wants to exit or if the input is valid.
         <pre><code>
char choice;
do {
    printf("Menu:\\n1. Option A\\n2. Option B\\n3. Exit\\n");
    printf("Enter your choice: ");
    scanf(" %c", &amp;choice);
    // Process choice...
} while (choice != '3');
                            </code></pre>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. What are the differences between 'break' and 'continue'? / Distinguish between 'break' and 'continue" statement with appropriate examples.
       </h4>
       <ul>
        <li>
         <strong>
          break Statement:
         </strong>
         <ul>
          <li>
           <strong>
            Function:
           </strong>
           It immediately
           <strong>
            terminates
           </strong>
           the entire loop (or switch statement) it is in.
          </li>
          <li>
           <strong>
            Behavior:
           </strong>
           Control passes to the first statement following the loop.
          </li>
          <li>
           <strong>
            Example:
           </strong>
           Print numbers from 1 to 10, but stop if the number is 5.
           <pre><code>
for (int i = 1; i &lt;= 10; i++) {
    if (i == 5) {
        break; // Exits the for loop completely
    }
    printf("%d ", i);
}
// Output: 1 2 3 4
                                    </code></pre>
          </li>
         </ul>
        </li>
        <li>
         <strong>
          continue Statement:
         </strong>
         <ul>
          <li>
           <strong>
            Function:
           </strong>
           It
           <strong>
            skips
           </strong>
           the rest of the current iteration of the loop.
          </li>
          <li>
           <strong>
            Behavior:
           </strong>
           The loop does not terminate. Instead, control passes to the beginning of the next iteration (the condition is re-evaluated).
          </li>
          <li>
           <strong>
            Example:
           </strong>
           Print numbers from 1 to 10, but skip the number 5.
           <pre><code>
for (int i = 1; i &lt;= 10; i++) {
    if (i == 5) {
        continue; // Skips the printf for this iteration
    }
    printf("%d ", i);
}
// Output: 1 2 3 4 6 7 8 9 10
                                    </code></pre>
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        4. Why 'goto' statement is discouraged to use?
       </h4>
       <p>
        The goto statement is discouraged in modern programming because it promotes the creation of unstructured code, often referred to as "spaghetti code." This leads to several significant problems:
       </p>
       <ol>
        <li>
         <strong>
          Poor Readability:
         </strong>
         goto allows for arbitrary jumps within a function, making the flow of control difficult to follow. This makes the code hard to read and understand.
        </li>
        <li>
         <strong>
          Difficult to Debug:
         </strong>
         Tracing the execution path in code with multiple goto statements is a nightmare, making it extremely difficult to find and fix bugs.
        </li>
        <li>
         <strong>
          Maintenance Issues:
         </strong>
         Unstructured code is hard to modify or extend without introducing new bugs.
        </li>
        <li>
         <strong>
          Violation of Structured Programming Principles:
         </strong>
         Structured programming is based on the principles of sequence, selection (if/switch), and iteration (while/for), which create programs with a clear, predictable, single-entry, single-exit flow. goto breaks this principle.
        </li>
       </ol>
       <p>
        While there are very rare, specific cases where goto might be used (e.g., breaking out of deeply nested loops in C), these can almost always be solved with better program design.
       </p>
      </article>
      <article>
       <h4>
        5. Write a C program to find out the prime numbers between 0 to 100. / Write a C program to find the prime numbers between 1-100.
       </h4>
       <pre><code>
#include <stdio.h>

int main() {
    int i, j, isPrime;

    printf("Prime numbers between 1 and 100 are:\\n");

    // Loop through each number from 2 to 100
    for (i = 2; i &lt;= 100; i++) {
        isPrime = 1; // Assume the number is prime initially

        // Check for factors from 2 up to i/2
        for (j = 2; j &lt;= i / 2; j++) {
            if (i % j == 0) {
                isPrime = 0; // Found a factor, so not prime
                break;       // No need to check further
            }
        }

        // If isPrime is still 1, then the number is prime
        if (isPrime == 1) {
            printf("%d ", i);
        }
    }
    printf("\\n");
    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        6. Write a C program to find the number and sum of all integers greater than 100 and less than 200 those are divisible by 7.
       </h4>
       <pre><code>
#include <stdio.h>

int main() {
    int i, sum = 0, count = 0;

    for (i = 101; i &lt; 200; i++) {
        if (i % 7 == 0) {
            sum += i;  // Add the number to the sum
            count++;   // Increment the count
        }
    }

    printf("The numbers between 100 and 200 divisible by 7 are:\\n");
    for (i = 101; i &lt; 200; i++) {
        if (i % 7 == 0) {
            printf("%d ", i);
        }
    }
    printf("\\n\\n");

    printf("Total count of such numbers: %d\\n", count);
    printf("Sum of these numbers: %d\\n", sum);

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        7. Define nested loop. Write a C code that will take a string (KLMNAYZ) as input and the output will be reverse of it (ZYANMLK).
       </h4>
       <p>
        A
        <strong>
         nested loop
        </strong>
        is a loop that is placed inside the body of another loop. The inner loop is executed completely for each single iteration of the outer loop. This structure is commonly used for working with two-dimensional data, like matrices, or for creating patterns.
       </p>
       <h5>
        C Code to Reverse a String:
       </h5>
       <p>
        (Note: A nested loop is not the efficient way to reverse a string. A single loop is sufficient. The following code provides a standard single-loop solution as it's the correct way to solve the problem.)
       </p>
       <pre><code>
#include <stdio.h>
#include <string.h>

int main() {
    char str[100], temp;
    int i, j;

    printf("Enter a string: ");
    scanf("%s", str);

    i = 0;
    j = strlen(str) - 1;

    // A single loop is used to swap characters from the ends towards the center
    while (i &lt; j) {
        // Swap characters
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;

        i++;
        j--;
    }

    printf("The reversed string is: %s\\n", str);

    return 0;
}
                    </string.h></stdio.h></code></pre>
      </article>
      <article>
       <h4>
        8. Write a C program to produce the following form of Floyd's triangle: 1/01/101/0101.
       </h4>
       <pre><code>
#include <stdio.h>

int main() {
    int rows = 4; // Number of rows to print
    int i, j, k = 1;

    printf("Floyd's Triangle (binary pattern):\\n");

    for (i = 1; i &lt;= rows; i++) {
        for (j = 1; j &lt;= i; j++) {
            // Use modulo 2 to alternate between 1 and 0
            if ((i + j) % 2 == 0) {
                printf("1");
            } else {
                printf("0");
            }
        }
        printf("\\n"); // Move to the next line after each row
    }

    return 0;
}
                    </stdio.h></code></pre>
       <p>
        *(Note: The question's output 1/01/101/0101 seems to use / as a separator. The code above uses newlines, which is standard for triangles. If / is required, printf("\\n"); can be changed to if (i &lt; rows) printf("/");)*
       </p>
      </article>
     </section>
     <section id="functions-and-calling-procedures">
      <h3>
       f. Functions and Calling Procedures
      </h3>
      <article>
       <h4>
        1. Distinguish between 'call by value' and 'call by reference' of function calling. / Explain call by value and call by reference using suitable example.
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           Call by Value
          </th>
          <th>
           Call by Reference
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Mechanism
           </strong>
          </td>
          <td>
           The
           <strong>
            value
           </strong>
           of the actual argument is copied into the formal argument of the function.
          </td>
          <td>
           The
           <strong>
            address
           </strong>
           of the actual argument is passed to the formal argument (pointer) of the function.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Effect on Original Data
           </strong>
          </td>
          <td>
           Modifications made to the formal argument inside the function
           <strong>
            do not affect
           </strong>
           the original actual argument.
          </td>
          <td>
           Modifications made to the dereferenced formal argument inside the function
           <strong>
            do affect
           </strong>
           the original actual argument.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Memory
           </strong>
          </td>
          <td>
           Two separate memory locations are created for the actual and formal arguments.
          </td>
          <td>
           Both the actual argument and the formal pointer argument refer to the same memory location.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Implementation in C
           </strong>
          </td>
          <td>
           Default method for passing variables.
          </td>
          <td>
           Achieved by passing pointers as arguments.
          </td>
         </tr>
        </tbody>
       </table>
       <h5>
        Example:
       </h5>
       <pre><code>
#include <stdio.h>

// Function using call by value
void incrementByValue(int x) {
    x = x + 1;
    printf("Inside incrementByValue, x = %d\\n", x);
}

// Function using call by reference
void incrementByReference(int *x_ptr) {
    *x_ptr = *x_ptr + 1;
    printf("Inside incrementByReference, *x_ptr = %d\\n", *x_ptr);
}

int main() {
    int a = 10;
    int b = 10;

    printf("Original a = %d\\n", a);
    incrementByValue(a);
    printf("After call by value, a = %d\\n\\n", a); // a will still be 10

    printf("Original b = %d\\n", b);
    incrementByReference(&amp;b);
    printf("After call by reference, b = %d\\n", b); // b will be 11

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        2. Explain the difference between local and global variable with example. / Distinguish between the following terms: ii) local variable and global variable. / Delineate global, local and static variables.
       </h4>
       <ul>
        <li>
         <strong>
          Local Variable:
         </strong>
         <ul>
          <li>
           <strong>
            Scope:
           </strong>
           Declared inside a function or a block. They are only accessible within that function/block.
          </li>
          <li>
           <strong>
            Lifetime:
           </strong>
           Created when the function/block is entered and destroyed when it is exited.
          </li>
          <li>
           <strong>
            Default Value:
           </strong>
           Garbage value.
          </li>
          <li>
           <strong>
            Example:
           </strong>
           In void func() { int x = 5; }, x is a local variable.
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Global Variable:
         </strong>
         <ul>
          <li>
           <strong>
            Scope:
           </strong>
           Declared outside of all functions, usually at the top of the program. They are accessible by any function in the program.
          </li>
          <li>
           <strong>
            Lifetime:
           </strong>
           Exists for the entire duration of the program's execution.
          </li>
          <li>
           <strong>
            Default Value:
           </strong>
           Zero.
          </li>
          <li>
           <strong>
            Example:
           </strong>
           <pre><code>
int global_var = 10; // Global variable
void func() { /* can access global_var */ }
int main() { /* can access global_var */ return 0; }
                                    </code></pre>
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Static Variable:
         </strong>
         <ul>
          <li>
           The static keyword changes the lifetime and visibility of a variable.
          </li>
          <li>
           <strong>
            Static Local Variable:
           </strong>
           When declared inside a function, it retains its value between function calls. Its lifetime is the entire program execution, but its scope is still local to the function.
           <pre><code>
void counter() {
    static int count = 0; // Initialized only once
    count++;
    printf("%d ", count);
}
// Calling counter() three times prints "1 2 3"
                                    </code></pre>
          </li>
          <li>
           <strong>
            Static Global Variable:
           </strong>
           When declared at the file scope, its scope is restricted to the file in which it is declared. It cannot be accessed by other files using extern.
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. Distinguish between the following terms: i) actual argument and formal arguments.
       </h4>
       <ul>
        <li>
         <strong>
          Actual Arguments (or Arguments):
         </strong>
         These are the variables or values that are passed to a function when it is
         <strong>
          called
         </strong>
         . They are specified within the parentheses of the function call.
         <ul>
          <li>
           <strong>
            Example:
           </strong>
           In the call sum(a, b);, a and b are the actual arguments.
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Formal Arguments (or Parameters):
         </strong>
         These are the variables that are declared in the
         <strong>
          function definition
         </strong>
         (or prototype). They act as placeholders that receive the values of the actual arguments when the function is called.
         <ul>
          <li>
           <strong>
            Example:
           </strong>
           In the function definition int sum(int x, int y) {... }, x and y are the formal arguments.
          </li>
         </ul>
        </li>
       </ul>
       <p>
        When sum(a, b) is called, the value of a is copied into x and the value of b is copied into y.
       </p>
      </article>
      <article>
       <h4>
        4. Is it possible to declare two functions with the same name? Write a short note on argument and parameter of a function with appropriate examples.
       </h4>
       <p>
        In the
        <strong>
         C programming language
        </strong>
        , it is
        <strong>
         not possible
        </strong>
        to declare two functions with the same name within the same scope. The C language does not support function overloading. Each function must have a unique name.
       </p>
       <p>
        (Note: In C++, it is possible through function overloading, where functions can have the same name as long as their parameter lists are different in type or number.)
       </p>
       <h5>
        Short note on Argument and Parameter:
       </h5>
       <p>
        The terms "argument" and "parameter" are often used interchangeably, but they have distinct meanings in programming.
       </p>
       <ul>
        <li>
         A
         <strong>
          parameter
         </strong>
         is the variable listed inside the parentheses in the function
         <strong>
          definition
         </strong>
         . It is a placeholder.
         <ul>
          <li>
           Example: void printValue(int num) - here, num is the parameter.
          </li>
         </ul>
        </li>
        <li>
         An
         <strong>
          argument
         </strong>
         is the actual value that is sent to the function when it is
         <strong>
          called
         </strong>
         .
         <ul>
          <li>
           Example: printValue(10); - here, 10 is the argument.
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        5. Define user define function.
       </h4>
       <p>
        A user-defined function is a block of code written by the programmer to perform a specific, self-contained task. Unlike built-in library functions (like printf or sqrt), user-defined functions are created by the user to modularize their code.
       </p>
       <p>
        Creating functions helps to:
       </p>
       <ul>
        <li>
         Break down a large program into smaller, manageable pieces.
        </li>
        <li>
         Promote code reusability, as the same function can be called multiple times.
        </li>
        <li>
         Improve the readability and maintainability of the code.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        6. Define function prototyping with example. Why it is important?
       </h4>
       <p>
        A
        <strong>
         function prototype
        </strong>
        is a declaration of a function that specifies its name, return type, and the data types of its parameters. It does not contain the function body. It is typically placed at the beginning of a program.
       </p>
       <h5>
        Example:
       </h5>
       <pre><code>
#include <stdio.h>

// Function prototype
int add(int a, int b);

int main() {
    int result = add(5, 10); // Function call
    printf("Result: %d\\n", result);
    return 0;
}

// Function definition
int add(int a, int b) {
    return a + b;
}
                    </stdio.h></code></pre>
       <h5>
        Importance of Prototyping:
       </h5>
       <p>
        Function prototyping is crucial because it provides the compiler with information about the function before it is called. This allows the compiler to perform type checking. It can verify that the function is being called with the correct number and types of arguments. If there is a mismatch, the compiler will generate an error or a warning, helping to catch bugs early in the development process. Without a prototype, the compiler might make incorrect assumptions, leading to unexpected runtime errors.
       </p>
      </article>
     </section>
     <section id="recursion">
      <h3>
       g. Recursion
      </h3>
      <article>
       <h4>
        1. Define recursion.
       </h4>
       <p>
        Recursion is a programming technique where a function calls itself, either directly or indirectly, in order to solve a problem. A recursive function breaks a problem down into smaller, similar subproblems until it reaches a simple base case that can be solved directly without further recursion.
       </p>
      </article>
      <article>
       <h4>
        2. Write a C program to find factorial of a number using recursion. / Write down a C program to find the factorial of n by using recursion, n is a positive integer.
       </h4>
       <pre><code>
#include <stdio.h>

long long factorial(int n) {
    // Base case: factorial of 0 or 1 is 1
    if (n == 0 || n == 1) {
        return 1;
    }
    // Recursive step: n * factorial of (n-1)
    else {
        return n * factorial(n - 1);
    }
}

int main() {
    int num;
    printf("Enter a positive integer: ");
    scanf("%d", #);

    if (num &lt; 0) {
        printf("Factorial is not defined for negative numbers.\\n");
    } else {
        printf("Factorial of %d = %lld\\n", num, factorial(num));
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        3. Write a C program to calculate Fibonacci series using recursion. The Fibonacci series looks like 0,1,1,2,3,5,8,13...
       </h4>
       <pre><code>
#include <stdio.h>

// Function to find the nth Fibonacci number
int fibonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n, i;
    printf("Enter the number of terms for Fibonacci series: ");
    scanf("%d", &amp;n);

    printf("Fibonacci Series: ");
    for (i = 0; i &lt; n; i++) {
        printf("%d ", fibonacci(i));
    }
    printf("\\n");

    return 0;
}
                    </stdio.h></code></pre>
       <p>
        *(Note: This recursive solution for Fibonacci is elegant but highly inefficient for larger n due to repeated calculations.)*
       </p>
      </article>
      <article>
       <h4>
        4. Write a program using recursive function to print Fibonacci Series.
       </h4>
       <p>
        (The code provided in the answer to question 3 serves this purpose.)
       </p>
      </article>
      <article>
       <h4>
        5. Write a C program to find the sum of 1 to N using recursion. Here N is user input value.
       </h4>
       <pre><code>
#include <stdio.h>

int sumOfN(int n) {
    // Base case
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return n + sumOfN(n - 1);
}

int main() {
    int num;
    printf("Enter a positive integer N: ");
    scanf("%d", #);

    if (num &lt;= 0) {
        printf("Please enter a positive integer.\\n");
    } else {
        printf("Sum of numbers from 1 to %d is: %d\\n", num, sumOfN(num));
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        6. What is base case in recursion? Why does stack overflow occur in recursion? Explain with suitable example.
       </h4>
       <h5>
        Base Case:
       </h5>
       <p>
        The base case (or terminating condition) is the part of a recursive function that does not make a further recursive call. It is the simplest version of the problem that can be solved directly. A base case is essential to prevent the recursion from continuing indefinitely.
       </p>
       <h5>
        Stack Overflow:
       </h5>
       <p>
        When a function is called, an activation record (containing its local variables, parameters, and return address) is pushed onto the call stack. In recursion, each recursive call pushes a new record onto the stack.
       </p>
       <p>
        A
        <strong>
         stack overflow
        </strong>
        occurs when the recursive calls are too deep, and the call stack runs out of its allocated memory space. This happens when the recursion does not stop, which is typically caused by one of two things:
       </p>
       <ol>
        <li>
         <strong>
          Missing Base Case:
         </strong>
         The function has no condition to stop calling itself.
        </li>
        <li>
         <strong>
          Incorrect Base Case:
         </strong>
         The recursive calls never converge to the base case.
        </li>
       </ol>
       <h5>
        Example: A factorial function without a base case.
       </h5>
       <pre><code>
int faultyFactorial(int n) {
    // Missing base case: if (n == 0) return 1;
    return n * faultyFactorial(n - 1);
}

int main() {
    // Calling faultyFactorial(5) will lead to:
    // 5 * faultyFactorial(4)
    // 5 * 4 * faultyFactorial(3)
    //...
    //... * faultyFactorial(0)
    //... * faultyFactorial(-1)
    //... and so on, never stopping.
    // Eventually, the call stack will be exhausted, causing a stack overflow error.
    faultyFactorial(5);
    return 0;
}
                    </code></pre>
      </article>
     </section>
     <section id="arrays-and-pointers">
      <h3>
       h. Arrays and Pointers
      </h3>
      <article>
       <h4>
        1. Define array. What are the limitations of array processing? Explain.
       </h4>
       <p>
        An
        <strong>
         array
        </strong>
        is a data structure that stores a collection of elements of the
        <strong>
         same data type
        </strong>
        in
        <strong>
         contiguous memory locations
        </strong>
        . Each element can be accessed directly using its index (or subscript).
       </p>
       <h5>
        Limitations of Array Processing:
       </h5>
       <ol>
        <li>
         <strong>
          Fixed Size:
         </strong>
         The size of an array is fixed at the time of its declaration and cannot be changed during program execution. This can lead to either wastage of memory (if the array is too large) or insufficient space (if it's too small).
        </li>
        <li>
         <strong>
          Homogeneous Data Type:
         </strong>
         Arrays can only store elements of the same data type. You cannot store a mix of integers, characters, and floats in a single C array.
        </li>
        <li>
         <strong>
          Costly Insertion and Deletion:
         </strong>
         Inserting or deleting an element in the middle of an array is inefficient. It requires shifting all subsequent elements, which is a time-consuming operation, especially for large arrays.
        </li>
        <li>
         <strong>
          No Bound Checking:
         </strong>
         C does not perform automatic bounds checking on arrays. Accessing an element outside the array's bounds (e.g., arr[10] in a 10-element array arr[0...9]) leads to undefined behavior and can corrupt memory or crash the program.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        2. How 1-D and 2-D array elements are stored in memory? Explain with example.
       </h4>
       <h5>
        1-D Array Storage:
       </h5>
       <p>
        A one-dimensional (1-D) array is stored as a simple linear sequence of elements in contiguous memory locations. If an integer array int arr[4]; starts at memory address 1000, and an int takes 4 bytes, the elements will be stored as follows:
       </p>
       <ul>
        <li>
         arr[0] at address 1000
        </li>
        <li>
         arr[1] at address 1004
        </li>
        <li>
         arr[2] at address 1008
        </li>
        <li>
         arr[3] at address 1012
        </li>
       </ul>
       <h5>
        2-D Array Storage:
       </h5>
       <p>
        A two-dimensional (2-D) array is conceptually a grid or table, but in memory, it is flattened and stored as a contiguous block. C uses row-major order for storage. This means that all elements of the first row are stored first, followed by all elements of the second row, and so on.
       </p>
       <p>
        <strong>
         Example:
        </strong>
        For int matrix[2][3] = {{1, 2, 3}, {4, 5, 6}}; starting at address 2000:
       </p>
       <ul>
        <li>
         <strong>
          Row 0:
         </strong>
         matrix[0][0] (1) at 2000, matrix[0][1] (2) at 2004, matrix[0][2] (3) at 2008
        </li>
        <li>
         <strong>
          Row 1:
         </strong>
         matrix[1][0] (4) at 2012, matrix[1][1] (5) at 2016, matrix[1][2] (6) at 2020
        </li>
       </ul>
       <p>
        The entire 2x3 array is stored as a single block of 6 integers.
       </p>
      </article>
      <article>
       <h4>
        3. What is the difference between passing an array to a function and passing a single value data item to a function? Explain briefly with examples.
       </h4>
       <p>
        The key difference is that passing a single value uses
        <strong>
         call by value
        </strong>
        , while passing an array uses
        <strong>
         call by reference
        </strong>
        .
       </p>
       <ul>
        <li>
         <strong>
          Passing a Single Value (Call by Value):
         </strong>
         <ul>
          <li>
           A
           <strong>
            copy
           </strong>
           of the variable's value is passed to the function.
          </li>
          <li>
           The function works on this copy. Any changes made inside the function
           <strong>
            do not affect
           </strong>
           the original variable in the calling function.
          </li>
          <li>
           <strong>
            Example:
           </strong>
           <pre><code>
void modifyValue(int x) { x = 100; }
int main() {
    int num = 10;
    modifyValue(num);
    // Here, num is still 10.
}
                                    </code></pre>
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Passing an Array (Effectively Call by Reference):
         </strong>
         <ul>
          <li>
           When an array is passed to a function, its name "decays" into a
           <strong>
            pointer
           </strong>
           to its first element.
          </li>
          <li>
           The function receives the memory address of the array. It does not receive a copy of the entire array.
          </li>
          <li>
           Any changes made to the array elements inside the function
           <strong>
            will affect
           </strong>
           the original array in the calling function because both refer to the same memory locations.
          </li>
          <li>
           <strong>
            Example:
           </strong>
           <pre><code>
void modifyArray(int arr[]) { arr[0] = 100; }
int main() {
    int myArr[] = {10, 20, 30};
    modifyArray(myArr);
    // Here, myArr[0] is now 100.
}
                                    </code></pre>
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        4. Differentiate between Array and Strings.
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           Array
          </th>
          <th>
           String (in C)
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Definition
           </strong>
          </td>
          <td>
           A collection of homogeneous elements stored in contiguous memory.
          </td>
          <td>
           A sequence of characters stored in a char array, terminated by a null character (\0).
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Data Type
           </strong>
          </td>
          <td>
           Can be of any data type (int, float, char, struct, etc.).
          </td>
          <td>
           Specifically an array of type char.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Termination
           </strong>
          </td>
          <td>
           Has no special terminator. Its size is known from its declaration.
          </td>
          <td>
           Must be terminated by the null character (\0) to mark its end.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Library Support
           </strong>
          </td>
          <td>
           Basic operations are done manually using loops.
          </td>
          <td>
           Has a rich set of library functions in
           <string.h>
            for manipulation (e.g., strcpy, strlen, strcmp).
           </string.h>
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Initialization
           </strong>
          </td>
          <td>
           int arr[] = {1, 2, 3};
          </td>
          <td>
           char str[] = "hello"; (null terminator is added automatically) or char str[] = {'h','e','l','l','o','\0'};
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        5. Define pointer. Write down the disadvantages of it.
       </h4>
       <p>
        A
        <strong>
         pointer
        </strong>
        is a special type of variable that stores the memory address of another variable. Instead of holding a value like an integer or character, it "points to" the location where a value is stored.
       </p>
       <h5>
        Disadvantages of Pointers:
       </h5>
       <ol>
        <li>
         <strong>
          Complexity:
         </strong>
         Pointers can make code harder to understand and reason about, especially with complex pointer arithmetic or multiple levels of indirection (pointer to a pointer).
        </li>
        <li>
         <strong>
          Security Risks:
         </strong>
         Improper use of pointers can lead to serious security vulnerabilities, such as buffer overflows, which can be exploited by malicious code.
        </li>
        <li>
         <strong>
          Bugs and Errors:
         </strong>
         Pointers are a common source of bugs:
         <ul>
          <li>
           <strong>
            Null Pointer Dereferencing:
           </strong>
           Attempting to access the memory location pointed to by a NULL pointer, which causes a program crash.
          </li>
          <li>
           <strong>
            Dangling Pointers:
           </strong>
           A pointer that points to a memory location that has already been deallocated (freed). Using it can lead to unpredictable behavior.
          </li>
          <li>
           <strong>
            Memory Leaks:
           </strong>
           If memory is allocated dynamically using malloc() and not deallocated using free(), the pointer to that memory may be lost, leading to a memory leak where the memory cannot be reclaimed.
          </li>
         </ul>
        </li>
       </ol>
      </article>
      <article>
       <h4>
        6. What is NULL pointer? Why is it necessary?
       </h4>
       <p>
        A
        <strong>
         NULL pointer
        </strong>
        is a special pointer value that indicates that the pointer is not pointing to any valid memory address. In C, it is typically defined as (void *)0.
       </p>
       <h5>
        Necessity of NULL Pointers:
       </h5>
       <ol>
        <li>
         <strong>
          Initialization:
         </strong>
         It is a good practice to initialize pointers to NULL if they are not being assigned a valid memory address immediately. This prevents them from holding a garbage address.
        </li>
        <li>
         <strong>
          Error Checking:
         </strong>
         Functions that return pointers (e.g., malloc) can return NULL to signal an error or failure (e.g., memory could not be allocated). The calling code can then check for a NULL return value to handle the error gracefully.
        </li>
        <li>
         <strong>
          Signaling End of Data Structures:
         </strong>
         NULL pointers are widely used to mark the end of data structures, such as the next pointer in the last node of a linked list.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        7. Illustrate how pointer works? Use necessary figures.
       </h4>
       <p>
        A pointer works by storing a memory address. Let's illustrate this with a conceptual description.
       </p>
       <p>
        Imagine the computer's memory as a series of numbered boxes, where each number is a memory address.
       </p>
       <ol>
        <li>
         A Regular Variable:
         <p>
          When you declare int var = 25;, the computer allocates a box, say at address 1004, and puts the value 25 inside it.
         </p>
         <ul>
          <li>
           var (The variable) -&gt; has the value 25
          </li>
          <li>
           &amp;var (Address of var) -&gt; is 1004
          </li>
         </ul>
        </li>
        <li>
         A Pointer Variable:
         <p>
          When you declare int *ptr;, the computer allocates another box for the pointer itself, say at address 2008. This box is meant to hold an address.
         </p>
        </li>
        <li>
         Assigning the Address:
         <p>
          The statement ptr = &amp;var takes the address of var (which is 1004) and stores this address inside the box for ptr.
         </p>
         <ul>
          <li>
           ptr (The pointer) -&gt; has the value 1004
          </li>
          <li>
           &amp;ptr (Address of ptr) -&gt; is 2008
          </li>
         </ul>
        </li>
        <li>
         Dereferencing:
         <p>
          The * operator (dereference or indirection operator) is used to access the value at the address stored in the pointer.
         </p>
         <ul>
          <li>
           *ptr means "go to the address stored in ptr (which is 1004) and get the value from that box".
          </li>
          <li>
           So, *ptr evaluates to 25.
          </li>
         </ul>
        </li>
       </ol>
       <p>
        Modifying *ptr (e.g., *ptr = 50;) would change the value in the box at address 1004, thus changing the value of var to 50.
       </p>
      </article>
      <article>
       <h4>
        8. Distinguish between the following statements. (i) Pointer and Array. (ii) Pointer and String.
       </h4>
       <h5>
        (i) Pointer and Array
       </h5>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           Array
          </th>
          <th>
           Pointer
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Definition
           </strong>
          </td>
          <td>
           A collection of elements of the same type in contiguous memory.
          </td>
          <td>
           A variable that stores the memory address of another variable.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Nature
           </strong>
          </td>
          <td>
           The array name itself represents a block of memory.
          </td>
          <td>
           A pointer is a separate variable that holds an address.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Re- assignment
           </strong>
          </td>
          <td>
           An array name is a
           <strong>
            constant
           </strong>
           pointer; it cannot be reassigned to point to another location. arr =...; is illegal.
          </td>
          <td>
           A pointer is a
           <strong>
            variable
           </strong>
           ; it can be reassigned to point to different memory locations. ptr =...; is legal.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            sizeof Operator
           </strong>
          </td>
          <td>
           sizeof(arr) returns the total size of the array in bytes (number of elements * size of one element).
          </td>
          <td>
           sizeof(ptr) returns the size of the pointer variable itself (typically 4 or 8 bytes), regardless of what it points to.
          </td>
         </tr>
        </tbody>
       </table>
       <h5>
        (ii) Pointer and String
       </h5>
       <ul>
        <li>
         A
         <strong>
          string
         </strong>
         in C is a char array terminated by a null character (\0). It is a data structure.
        </li>
        <li>
         A
         <strong>
          pointer
         </strong>
         (specifically a char *) is a variable used to
         <em>
          manipulate
         </em>
         a string.
        </li>
       </ul>
       <p>
        The relationship is very close. A string literal like "hello" creates an anonymous, null-terminated character array in memory, and the expression evaluates to a pointer to its first character.
       </p>
       <p>
        Example:
        <br/>
        char str_array[] = "hello"; // str_array is an array of 6 chars.
        <br/>
        char *str_ptr = "hello"; // str_ptr is a pointer to the first char 'h' of a string literal stored elsewhere (often in read-only memory).
        <br/>
        The key difference is that str_array is a mutable array, while str_ptr points to a string literal which should not be modified.
       </p>
      </article>
      <article>
       <h4>
        9. Write a C program to multiply matrix. / Write a C code to multiply two 3x3 matrices.
       </h4>
       <pre><code>
#include <stdio.h>

#define N 3

int main() {
    int A[N][N], B[N][N], C[N][N];
    int i, j, k;

    printf("Enter elements of matrix A (3x3):\\n");
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; N; j++) {
            scanf("%d", &amp;A[i][j]);
        }
    }

    printf("Enter elements of matrix B (3x3):\\n");
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; N; j++) {
            scanf("%d", &amp;B[i][j]);
        }
    }

    // Initialize result matrix C to 0
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; N; j++) {
            C[i][j] = 0;
        }
    }

    // Perform matrix multiplication C = A * B
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; N; j++) {
            for (k = 0; k &lt; N; k++) {
                C[i][j] += A[i][k] * B[k][j];
            }
        }
    }

    printf("Resultant matrix C (A * B) is:\\n");
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; N; j++) {
            printf("%d\\t", C[i][j]);
        }
        printf("\\n");
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        10. Write a program in C where a function will add two 2x2 matrices and the matrices will be sent from the 'main() function. Finally return and display the resultant matrix in the main() function.
       </h4>
       <pre><code>
#include <stdio.h>

#define N 2

// Function to add two matrices.
// Note: C doesn't allow returning an entire array directly.
// We pass the result matrix as a parameter to be filled by the function.
void addMatrices(int A[][N], int B[][N], int C[][N]) {
    int i, j;
    for (i = 0; i &lt; N; i++) {
        for (j = 0; j &lt; N; j++) {
            C[i][j] = A[i][j] + B[i][j];
        }
    }
}

int main() {
    int A[N][N] = {{1, 2}, {3, 4}};
    int B[N][N] = {{5, 6}, {7, 8}};
    int C[N][N]; // Resultant matrix

    // Call the function to add matrices
    addMatrices(A, B, C);

    printf("Resultant matrix C (A + B) is:\\n");
    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; N; j++) {
            printf("%d\\t", C[i][j]);
        }
        printf("\\n");
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        11. Write a program using C to compute transpose of a matrix.
       </h4>
       <pre><code>
#include <stdio.h>

#define ROWS 3
#define COLS 3

int main() {
    int matrix[ROWS][COLS], transpose[COLS][ROWS];
    int i, j;

    printf("Enter elements of the matrix (%dx%d):\\n", ROWS, COLS);
    for (i = 0; i &lt; ROWS; i++) {
        for (j = 0; j &lt; COLS; j++) {
            scanf("%d", &amp;matrix[i][j]);
        }
    }

    // Compute the transpose
    for (i = 0; i &lt; ROWS; i++) {
        for (j = 0; j &lt; COLS; j++) {
            transpose[j][i] = matrix[i][j];
        }
    }

    printf("The transpose of the matrix is:\\n");
    for (i = 0; i &lt; COLS; i++) {
        for (j = 0; j &lt; ROWS; j++) {
            printf("%d\\t", transpose[i][j]);
        }
        printf("\\n");
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        12. Write a C program for sorting a one dimensional array in ascending order. / Write C code to store numbers according to descending order.
       </h4>
       <h5>
        Ascending Order (using Bubble Sort):
       </h5>
       <pre><code>
#include <stdio.h>

int main() {
    int arr[100], n, i, j, temp;

    printf("Enter number of elements: ");
    scanf("%d", &amp;n);

    printf("Enter %d integers:\\n", n);
    for (i = 0; i &lt; n; i++) {
        scanf("%d", &amp;arr[i]);
    }

    // Bubble sort algorithm for ascending order
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                // Swap elements
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    printf("Sorted array in ascending order:\\n");
    for (i = 0; i &lt; n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\\n");

    return 0;
}
                    </stdio.h></code></pre>
       <p>
        <strong>
         Descending Order:
        </strong>
        To sort in descending order, simply change the comparison in the if statement from &gt; to &lt;: if (arr[j] &lt; arr[j + 1]).
       </p>
      </article>
      <article>
       <h4>
        13. Write a program to read an array of integers using pointer variable. Find the maximum integer from the array elements utilizing pointer.
       </h4>
       <pre><code>
#include <stdio.h>

int main() {
    int arr[100], n, i;
    int *ptr;
    int max;

    printf("Enter number of elements: ");
    scanf("%d", &amp;n);

    ptr = arr; // Point ptr to the beginning of the array

    printf("Enter %d integers:\\n", n);
    for (i = 0; i &lt; n; i++) {
        // Read into array using pointer arithmetic
        scanf("%d", ptr + i);
    }

    // Assume first element is max
    max = *ptr;

    // Find maximum using pointer
    for (i = 1; i &lt; n; i++) {
        if (*(ptr + i) &gt; max) {
            max = *(ptr + i);
        }
    }

    printf("The maximum element is: %d\\n", max);

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        14. Write a C program to find two elements of an array, whose summation is closer to zero.
       </h4>
       <pre><code>
#include <stdio.h>
#include <stdlib.h> // For abs()
#include <limits.h> // For INT_MAX

int main() {
    int arr[] = {10, -20, 5, 30, -2, 15};
    int n = sizeof(arr) / sizeof(arr[0]);
    int i, j;
    int min_sum = INT_MAX;
    int sum;
    int el1, el2;

    if (n &lt; 2) {
        printf("Array must have at least two elements.\\n");
        return 1;
    }

    for (i = 0; i &lt; n - 1; i++) {
        for (j = i + 1; j &lt; n; j++) {
            sum = arr[i] + arr[j];
            if (abs(sum) &lt; abs(min_sum)) {
                min_sum = sum;
                el1 = arr[i];
                el2 = arr[j];
            }
        }
    }

    printf("The two elements whose sum is closest to zero are %d and %d.\\n", el1, el2);
    printf("Their sum is %d.\\n", min_sum);

    return 0;
}
                    </limits.h></stdlib.h></stdio.h></code></pre>
      </article>
      <article>
       <h4>
        15. Write a computer program to calculate the standard deviation of an array of values. The array elements are read from the terminal.
       </h4>
       <pre><code>
#include <stdio.h>
#include <math.h>

int main() {
    int n, i;
    float arr[100];
    float sum = 0.0, mean = 0.0, std_dev = 0.0;

    printf("Enter the number of elements: ");
    scanf("%d", &amp;n);

    printf("Enter %d real numbers:\\n", n);
    for (i = 0; i &lt; n; ++i) {
        scanf("%f", &amp;arr[i]);
        sum += arr[i];
    }

    // Calculate the mean (average)
    mean = sum / n;

    // Calculate the sum of squared differences from the mean
    for (i = 0; i &lt; n; ++i) {
        std_dev += pow(arr[i] - mean, 2);
    }

    // Calculate the standard deviation
    std_dev = sqrt(std_dev / n);

    printf("Standard Deviation = %.6f\\n", std_dev);

    return 0;
}
                    </math.h></stdio.h></code></pre>
      </article>
      <article>
       <h4>
        16. Briefly describe the multi-dimensional array with its initialization in C.
       </h4>
       <p>
        A
        <strong>
         multi-dimensional array
        </strong>
        is an array of arrays. The most common type is a two-dimensional (2-D) array, which can be visualized as a table or grid with rows and columns. It is used to store data that is naturally represented in a tabular format, like matrices or game boards.
       </p>
       <h5>
        Declaration:
       </h5>
       <p>
        A 2-D array is declared by specifying the data type, name, number of rows, and number of columns.
        <br/>
        data_type array_name[ROWS][COLS];
       </p>
       <h5>
        Initialization:
       </h5>
       <p>
        Multi-dimensional arrays can be initialized at the time of declaration. The initial values are enclosed in braces {}. For a 2-D array, each row's values can be enclosed in their own inner set of braces.
       </p>
       <h5>
        Examples:
       </h5>
       <pre><code>
// Method 1: Specifying inner braces for each row (preferred)
int matrix[2][3] = { {1, 2, 3}, {4, 5, 6} };

// Method 2: Without inner braces (less readable)
// The elements are assigned row by row.
int matrix[2][3] = {1, 2, 3, 4, 5, 6};

// Method 3: Omitting the row count (compiler calculates it)
// The column count must always be specified.
int matrix[][3] = { {1, 2, 3}, {4, 5, 6} };
                    </code></pre>
      </article>
     </section>
     <section id="structure-and-union">
      <h3>
       i. Structure and Union
      </h3>
      <article>
       <h4>
        1. Differentiate between structure and union.
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           Structure (struct)
          </th>
          <th>
           Union (union)
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Memory Allocation
           </strong>
          </td>
          <td>
           Allocates separate memory space for
           <strong>
            each
           </strong>
           of its members.
          </td>
          <td>
           Allocates a
           <strong>
            single shared
           </strong>
           memory space for
           <strong>
            all
           </strong>
           its members.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Size
           </strong>
          </td>
          <td>
           The size of a structure is the sum of the sizes of all its members (plus any padding).
          </td>
          <td>
           The size of a union is the size of its
           <strong>
            largest
           </strong>
           member.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Value Storage
           </strong>
          </td>
          <td>
           Can store values in all its members simultaneously.
          </td>
          <td>
           Can only store a value in
           <strong>
            one
           </strong>
           of its members at any given time.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Purpose
           </strong>
          </td>
          <td>
           To group together related data items of different types.
          </td>
          <td>
           To use a single memory location to store different types of data at different times, saving memory.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Keyword
           </strong>
          </td>
          <td>
           struct
          </td>
          <td>
           union
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        2. Differentiate between Structure and Array.
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           Structure (struct)
          </th>
          <th>
           Array
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Data Type
           </strong>
          </td>
          <td>
           <strong>
            Heterogeneous
           </strong>
           . Can contain members of different data types (e.g., int, char, float).
          </td>
          <td>
           <strong>
            Homogeneous
           </strong>
           . All elements must be of the same data type.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Member Access
           </strong>
          </td>
          <td>
           Members are accessed by their names using the dot (.) operator (e.g., student.roll).
          </td>
          <td>
           Elements are accessed by their integer index using the subscript operator [] (e.g., arr[0]).
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Keyword
           </strong>
          </td>
          <td>
           Defined using the struct keyword.
          </td>
          <td>
           No special keyword; defined by its syntax (e.g., int arr[10];).
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Purpose
           </strong>
          </td>
          <td>
           To represent a record or a single entity with multiple properties.
          </td>
          <td>
           To store a list or sequence of similar items.
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        3. What is union?
       </h4>
       <p>
        A union is a user-defined data type in C that allows different types of data to be stored in the same memory location. It creates a single shared memory space that is large enough to hold the largest member of the union. The primary purpose of a union is to save memory when a variable needs to store values of different types at different points in a program, but never at the same time.
       </p>
      </article>
      <article>
       <h4>
        4. Define a structure called cricket... write a program to read the information about 50 players and print a teamwise list...
       </h4>
       <pre><code>
#include <stdio.h>
#include <string.h>

#define MAX_PLAYERS 50

// Define the cricket structure
struct cricket {
    char playerName[50];
    char teamName[50];
    float battingAverage;
};

int main() {
    // Declare an array of 50 cricket players
    struct cricket player[MAX_PLAYERS];
    int n, i, j;
    char teams[MAX_PLAYERS][50];
    int team_count = 0;
    int is_unique;

    printf("Enter the number of players (up to 50): ");
    scanf("%d", &amp;n);

    // Read information for n players
    for (i = 0; i &lt; n; i++) {
        printf("\\nEnter details for Player %d:\\n", i + 1);
        printf("Player Name: ");
        scanf("%s", player[i].playerName);
        printf("Team Name: ");
        scanf("%s", player[i].teamName);
        printf("Batting Average: ");
        scanf("%f", &amp;player[i].battingAverage);
    }

    // Find all unique team names
    for (i = 0; i &lt; n; i++) {
        is_unique = 1;
        for (j = 0; j &lt; team_count; j++) {
            if (strcmp(player[i].teamName, teams[j]) == 0) {
                is_unique = 0;
                break;
            }
        }
        if (is_unique) {
            strcpy(teams[team_count], player[i].teamName);
            team_count++;
        }
    }

    // Print the team-wise list
    printf("\\n--- Team-wise Player List ---\\n");
    for (i = 0; i &lt; team_count; i++) {
        printf("\\nTeam: %s\\n", teams[i]);
        printf("---------------------------\\n");
        printf("Player Name\\tBatting Average\\n");
        for (j = 0; j &lt; n; j++) {
            if (strcmp(teams[i], player[j].teamName) == 0) {
                printf("%s\\t\\t%.2f\\n", player[j].playerName, player[j].battingAverage);
            }
        }
    }

    return 0;
}
                    </string.h></stdio.h></code></pre>
      </article>
      <article>
       <h4>
        5. Write a program to store the roll no (starting from 1), name and age of 5 students and then print the details of the student with roll no 2 using structure.
       </h4>
       <pre><code>
#include <stdio.h>

// Define the student structure
struct student {
    int roll_no;
    char name[50];
    int age;
};

int main() {
    struct student students[5];
    int i;

    // Store information for 5 students
    printf("Enter details for 5 students:\\n");
    for (i = 0; i &lt; 5; i++) {
        students[i].roll_no = i + 1; // Assign roll number automatically
        printf("\\nStudent Roll No: %d\\n", students[i].roll_no);
        printf("Enter Name: ");
        scanf("%s", students[i].name);
        printf("Enter Age: ");
        scanf("%d", &amp;students[i].age);
    }

    // Find and print the details of the student with roll no 2
    printf("\\n--- Details of Student with Roll No 2 ---\\n");
    for (i = 0; i &lt; 5; i++) {
        if (students[i].roll_no == 2) {
            printf("Roll No: %d\\n", students[i].roll_no);
            printf("Name: %s\\n", students[i].name);
            printf("Age: %d\\n", students[i].age);
            break; // Exit loop once found
        }
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
     </section>
     <section id="applications-in-mechatronics-engineering">
      <h3>
       j. Applications in Mechatronics Engineering
      </h3>
      <article>
       <h4>
        1. Explain the usefulness of C program to control a ROBOT. / Illustrate the superior contribution of C program on the controlling of robotic and mechatronic systems.
       </h4>
       <p>
        The C programming language is highly useful and widely adopted for controlling robots and mechatronic systems due to its unique combination of features:
       </p>
       <ol>
        <li>
         <strong>
          High Performance:
         </strong>
         C compiles to fast, efficient machine code, which is critical for real-time control systems where timing and responsiveness are paramount.
        </li>
        <li>
         <strong>
          Low-Level Memory Access:
         </strong>
         C provides pointers, which allow for direct manipulation of memory addresses. This is essential for interfacing with hardware, such as reading sensor data from specific registers or controlling motors by writing to specific memory-mapped I/O ports.
        </li>
        <li>
         <strong>
          Hardware Proximity:
         </strong>
         C acts as a "portable assembly language," providing close control over hardware resources without sacrificing the structure and readability of a high-level language.
        </li>
        <li>
         <strong>
          Portability:
         </strong>
         C code is highly portable and can be compiled to run on a wide variety of microcontrollers and processors that are the "brains" of robotic systems.
        </li>
        <li>
         <strong>
          Extensive Ecosystem:
         </strong>
         C has a mature ecosystem with extensive libraries, compilers, and debuggers available for virtually every embedded platform.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        2. Suppose, a maze solving Robot... Write a C program to find the final position of the Robot if the initial position is (2,2) and the following commands are pressed ULDRR.
       </h4>
       <pre><code>
#include <stdio.h>
#include <string.h>

int main() {
    // Initial position
    int x = 2;
    int y = 2;

    char commands[] = "ULDRR";
    int i;
    int len = strlen(commands);

    printf("Initial Position: (%d, %d)\\n", x, y);
    printf("Commands: %s\\n", commands);

    // Process each command
    for (i = 0; i &lt; len; i++) {
        switch (commands[i]) {
            case 'U': // Up
                y++;
                break;
            case 'D': // Down
                y--;
                break;
            case 'L': // Left
                x--;
                break;
            case 'R': // Right
                x++;
                break;
            case 'S': // Stop
                // In this case, stop would just end the command processing
                goto end_loop; // Using goto for simple exit
            default:
                printf("Invalid command: %c\\n", commands[i]);
                break;
        }
    }

end_loop:
    printf("Final Position: (%d, %d)\\n", x, y);

    return 0;
}
                    </string.h></stdio.h></code></pre>
      </article>
      <article>
       <h4>
        3. Write a C program to find the node voltages and as shown in the provided figure.
       </h4>
       <p>
        <em>
         Since no figure is provided, a general explanation and a sample program to solve a simple system of two linear equations (which is a common result of nodal analysis) are given.
        </em>
       </p>
       <p>
        Nodal analysis in circuit theory typically results in a system of linear equations of the form Ax = B, where x represents the unknown node voltages. To find these voltages, one must solve this system of equations.
       </p>
       <h5>
        Example: Solving a 2-Node Circuit
       </h5>
       <p>
        Assume nodal analysis gives the following two equations:
        <br/>
        3*V1 - 1*V2 = 5
        <br/>
        -1*V1 + 4*V2 = 10
        <br/>
        The following C program uses Cramer's rule to solve this simple 2x2 system.
       </p>
       <pre><code>
#include <stdio.h>

int main() {
    // For a system of equations:
    // a1*x + b1*y = d1
    // a2*x + b2*y = d2

    float a1 = 3, b1 = -1, d1 = 5;
    float a2 = -1, b2 = 4, d2 = 10;

    float determinant, det_v1, det_v2;
    float v1, v2;

    // Calculate the main determinant of the coefficient matrix
    determinant = a1 * b2 - a2 * b1;

    if (determinant == 0) {
        printf("The system has no unique solution.\\n");
    } else {
        // Calculate determinant for V1
        det_v1 = d1 * b2 - d2 * b1;
        // Calculate determinant for V2
        det_v2 = a1 * d2 - a2 * d1;

        // Calculate V1 and V2
        v1 = det_v1 / determinant;
        v2 = det_v2 / determinant;

        printf("The node voltages are:\\n");
        printf("V1 = %.2f V\\n", v1);
        printf("V2 = %.2f V\\n", v2);
    }

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        4. Write a program to display the efficiency of a machinery, where the terms related to the calculation are taken from user by keyboard.
       </h4>
       <pre><code>
#include <stdio.h>

int main() {
    float input_power, output_power, efficiency;

    // Get input from the user
    printf("Enter the Input Power of the machinery (e.g., in Watts): ");
    scanf("%f", &amp;input_power);

    printf("Enter the Output Power of the machinery (e.g., in Watts): ");
    scanf("%f", &amp;output_power);

    // Validate the input
    if (input_power &lt;= 0) {
        printf("Error: Input power must be a positive value.\\n");
        return 1;
    }
    if (output_power &gt; input_power) {
        printf("Warning: Output power is greater than input power. Efficiency will be &gt; 100%%.\\n");
    }

    // Calculate the efficiency
    efficiency = (output_power / input_power) * 100.0;

    // Display the result
    printf("\\nThe efficiency of the machinery is: %.2f%%\\n", efficiency);

    return 0;
}
                    </stdio.h></code></pre>
      </article>
      <article>
       <h4>
        5. Write an algorithm to convert electrical energy to mechanical energy in a system.
       </h4>
       <p>
        This is a conceptual algorithm describing the process in a typical electromechanical system like a motor.
       </p>
       <ol>
        <li>
         <strong>
          START
         </strong>
        </li>
        <li>
         <strong>
          Provide Electrical Energy Source:
         </strong>
         Connect a power source (e.g., battery, AC mains) to the system.
        </li>
        <li>
         <strong>
          Generate Magnetic Field:
         </strong>
         Pass an electric current from the source through coils of wire (the stator in a motor). This converts electrical energy into a magnetic field according to Ampere's Law.
        </li>
        <li>
         <strong>
          Induce Force/Torque:
         </strong>
         Place a second component (the rotor, which can be a permanent magnet or another set of coils) within the magnetic field of the stator. The interaction between the magnetic fields creates a force (Lorentz force) that results in a torque, causing the rotor to turn.
        </li>
        <li>
         <strong>
          Produce Mechanical Work:
         </strong>
         Connect the rotating rotor to a shaft or other mechanical linkage. The rotation of the shaft represents kinetic mechanical energy, which can be used to perform work (e.g., turn a wheel, lift a weight).
        </li>
        <li>
         <strong>
          STOP
         </strong>
        </li>
       </ol>
      </article>
      <article>
       <h4>
        6. Suppose you want to develop a project. Then what is the necessity of programming in your projects? Explain briefly.
       </h4>
       <p>
        Programming is essential in modern projects, especially in fields like mechatronics, because it serves as the
        <strong>
         "brain" or intelligence
        </strong>
        that controls the project's hardware and defines its behavior.
       </p>
       <p>
        The necessity of programming can be summarized as:
       </p>
       <ol>
        <li>
         <strong>
          Control Logic:
         </strong>
         Programming implements the decision-making logic. It tells the project
         <em>
          what
         </em>
         to do,
         <em>
          when
         </em>
         to do it, and
         <em>
          how
         </em>
         to react to different inputs (e.g., "if sensor detects an obstacle, stop the motor").
        </li>
        <li>
         <strong>
          Data Processing:
         </strong>
         Projects often rely on collecting data from sensors. Programming is necessary to read this data, interpret it, perform calculations, and filter out noise.
        </li>
        <li>
         <strong>
          Automation:
         </strong>
         Programming automates complex or repetitive tasks, enabling a project to operate autonomously without constant human intervention.
        </li>
        <li>
         <strong>
          User Interface:
         </strong>
         It provides a way for humans to interact with the project, whether through a screen, buttons, or a remote connection.
        </li>
        <li>
         <strong>
          Flexibility:
         </strong>
         A project's functionality can be drastically changed or updated by simply modifying the software, without needing to redesign the physical hardware.
        </li>
       </ol>
      </article>
     </section>
    </section>
   </main>
  </div>
  <script src="../script.js">
  </script>
 </body>
</html>
