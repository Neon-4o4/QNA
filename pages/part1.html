<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   CSE 1287 QnA Solution
  </title>
  <script src="https://cdn.tailwindcss.com">
  </script>
  <link href="../style.css" rel="stylesheet"/>
 </head>
 <body class="bg-gray-100 font-sans">
  <!-- Sidebar -->
  <aside class="bg-gray-800 text-white w-64 min-h-screen p-4 fixed md:relative transform -translate-x-full md:translate-x-0 transition-transform duration-200 ease-in-out" id="sidebar">
   <nav>
    <ul>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700" href="part1.html">
       Part I: Computer Fundamentals
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="core-computer-organization.html">
       a. Core Computer Organization
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="storage-and-memory.html">
       b. Storage and Memory
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="number-systems.html">
       c. Number Systems
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="algorithms-and-flowcharts.html">
       d. Algorithms and Flowcharts
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="programming-language-levels.html">
       e. Programming Language Levels
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="language-translators.html">
       f. Language Translators
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="operating-systems-overview.html">
       g. Operating Systems Overview
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700" href="part2.html">
       Part II: Programming with C/C++
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="preliminaries.html">
       a. Preliminaries
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="io-statements.html">
       b. I/O Statements
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="expressions-and-operators.html">
       c. Expressions and Operators
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="decision-making.html">
       d. Decision Making
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="loops.html">
       e. Loops
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="functions-and-calling-procedures.html">
       f. Functions
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="recursion.html">
       g. Recursion
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="arrays-and-pointers.html">
       h. Arrays and Pointers
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="structure-and-union.html">
       i. Structure and Union
      </a>
     </li>
     <li>
      <a class="block py-2 px-4 rounded hover:bg-gray-700 ml-4" href="applications-in-mechatronics-engineering.html">
       j. Applications in Mechatronics
      </a>
     </li>
    </ul>
   </nav>
  </aside>
  <div class="flex flex-col flex-1">
   <header class="bg-white shadow-md p-4 flex justify-between items-center">
    <button class="md:hidden" id="sidebar-toggle">
     <svg class="w-6 h-6" fill="none" stroke="currentColor" viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
      <path d="M4 6h16M4 12h16M4 18h16" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
      </path>
     </svg>
    </button>
    <h1 class="text-xl font-semibold">
     CSE 1287 QnA (Year 2014-2023) - Solution
    </h1>
    <p>
     Generated By: Mahmud | 2308009
    </p>
   </header>
   <main class="p-8">
    <section id="part1">
     <h2>
      Part I: Computer Fundamentals
     </h2>
     <section id="core-computer-organization">
      <h3>
       a. Core Computer Organization
      </h3>
      <article>
       <h4>
        1. Draw a block diagram to illustrate the basic organization of a computer system, and explain the functions of control unit and central processing unit.
       </h4>
       <p>
        A block diagram of a computer system consists of four main units: the Input Unit, the Central Processing Unit (CPU), the Memory Unit, and the Output Unit. Data flows from the Input Unit to the Memory, then to the CPU for processing. The results are stored back in Memory and then sent to the a computer system consists of four main units: the Input Unit, the Central Processing Unit (CPU), the Memory Unit, and the Output Unit. Data flows from the Input Unit to the Memory, then to the CPU for processing. The results are stored back in Memory and then sent to the Output Unit.
       </p>
       <ul>
        <li>
         <strong>
          Central Processing Unit (CPU):
         </strong>
         The CPU is the "brain" of the computer, responsible for executing instructions and performing calculations.[1, 2] It fetches instructions from memory, decodes them, and executes them. The CPU comprises two main sub-units: the Arithmetic Logic Unit (ALU) and the Control Unit (CU).
         <ul>
          <li>
           <strong>
            Functions:
           </strong>
           <ol>
            <li>
             <strong>
              Instruction Execution:
             </strong>
             It carries out the instructions of a computer program.
            </li>
            <li>
             <strong>
              Arithmetic and Logic Operations:
             </strong>
             It performs all mathematical calculations (addition, subtraction) and logical comparisons (greater than, less than) via the ALU.
            </li>
            <li>
             <strong>
              Control of Operations:
             </strong>
             It manages and coordinates the operations of all other components of the computer.
            </li>
           </ol>
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Control Unit (CU):
         </strong>
         The CU is the "central nervous system" of the computer. It does not perform any actual data processing but directs and coordinates the activities of the entire computer system.[4, 5]
         <ul>
          <li>
           <strong>
            Functions:
           </strong>
           <ol>
            <li>
             <strong>
              Instruction Interpretation:
             </strong>
             It fetches program instructions from memory, decodes them, and converts them into control signals.[6]
            </li>
            <li>
             <strong>
              Data Flow Management:
             </strong>
             It directs the flow of data between the CPU, memory, and I/O devices.[7]
            </li>
            <li>
             <strong>
              Operation Sequencing:
             </strong>
             It controls the timing and sequence of all operations, ensuring instructions are executed in the correct order.[8]
            </li>
           </ol>
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        2. Define Computer. What are the fundamental parts of a computer? Discuss.
       </h4>
       <p>
        A computer is an electronic device that accepts data (input), processes it according to a set of instructions (program), produces results (output), and stores the data and results for future use.
       </p>
       <p>
        The fundamental parts of a computer can be categorized into two main groups: Hardware and Software.
       </p>
       <ol>
        <li>
         <strong>
          Hardware:
         </strong>
         These are the physical components of the computer system that can be seen and touched. The primary hardware components are:
         <ul>
          <li>
           <strong>
            Input Devices:
           </strong>
           Devices used to provide data and control signals to the computer. Examples include a keyboard, mouse, scanner, and microphone.
          </li>
          <li>
           <strong>
            Central Processing Unit (CPU):
           </strong>
           The core component that performs most of the processing inside the computer. It consists of the Control Unit (CU) and the Arithmetic Logic Unit (ALU).
          </li>
          <li>
           <strong>
            Memory Unit:
           </strong>
           Stores data, instructions, and processing results. It is divided into Primary Memory (RAM, ROM) for active data and Secondary Memory (HDD, SSD) for long-term storage.
          </li>
          <li>
           <strong>
            Output Devices:
           </strong>
           Devices used to present the processed data to the user. Examples include a monitor, printer, and speakers.
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Software:
         </strong>
         This is a set of instructions, data, or programs used to operate computers and execute specific tasks.
         <ul>
          <li>
           <strong>
            System Software:
           </strong>
           Manages and controls the computer hardware, providing a platform for application software to run. The most important system software is the Operating System (OS).
          </li>
          <li>
           <strong>
            Application Software:
           </strong>
           Programs designed for end-users to perform specific tasks, such as word processors, web browsers, and games.
          </li>
         </ul>
        </li>
       </ol>
      </article>
      <article>
       <h4>
        3. What happens when you press the power button on of a computer? / Elaborately explain the steps associated with pressing the power button on of a computer.
       </h4>
       <p>
        Pressing the power button initiates a sequence of events known as the boot process, which takes the computer from an inert state to a fully operational one. The steps are as follows:
       </p>
       <ol>
        <li>
         <strong>
          Power Supply Initialization:
         </strong>
         The Power Supply Unit (PSU) receives power and performs a self-test. If successful, it sends a "power good" signal to the motherboard, supplying stable electricity to all components, including the CPU, RAM, and storage devices.[9, 10]
        </li>
        <li>
         <strong>
          CPU Initialization:
         </strong>
         The CPU initializes itself and begins executing a program stored in a non-volatile firmware chip on the motherboard. This firmware is known as BIOS (Basic Input/Output System) or its modern successor, UEFI (Unified Extensible Firmware Interface).[11]
        </li>
        <li>
         <strong>
          Power-On Self-Test (POST):
         </strong>
         The BIOS/UEFI performs a POST, which is a diagnostic test to check that essential hardware components like the CPU, RAM, video card, and keyboard are present and functioning correctly. If an error is detected, the system may halt and issue beep codes or display an error message.[9, 12]
        </li>
        <li>
         <strong>
          Bootloader Loading:
         </strong>
         After a successful POST, the BIOS/UEFI searches for a bootable device according to a pre-configured boot order (e.g., SSD, HDD, USB drive). It locates the first sector of the device, which contains the Master Boot Record (MBR) in older systems or the GUID Partition Table (GPT) and EFI System Partition (ESP) in modern systems. This sector contains a small program called the bootloader.[11, 13]
        </li>
        <li>
         <strong>
          Operating System (OS) Kernel Loading:
         </strong>
         The bootloader's job is to load the core of the operating system, known as the kernel, from the storage device into the main memory (RAM). For example, Windows uses the Windows Boot Manager, and many Linux distributions use GRUB.[9]
        </li>
        <li>
         <strong>
          OS Initialization:
         </strong>
         Once the kernel is loaded into RAM, it takes control of the system. It initializes hardware drivers, mounts the file system, and starts essential system services and background processes (daemons).
        </li>
        <li>
         <strong>
          User Interface Launch:
         </strong>
         Finally, the OS starts the user interface, which could be a command-line interface (CLI) or a graphical user interface (GUI), presenting the user with a login screen or desktop environment. The boot process is now complete.[9]
        </li>
       </ol>
      </article>
      <article>
       <h4>
        4. Why are I/O devices necessary for a computer system? List out some I/O devices.
       </h4>
       <p>
        Input/Output (I/O) devices are necessary because they form the bridge between the human user and the computer's central processing unit. Without them, a computer would be an isolated system, unable to receive new information or present the results of its computations.
       </p>
       <p>
        Their necessity can be broken down into two key functions:
       </p>
       <ol>
        <li>
         <strong>
          Input:
         </strong>
         Computers need to receive data and instructions from the outside world to perform any task. Input devices convert human-readable information (like keystrokes or mouse movements) into a machine-readable binary format that the CPU can process.[1, 4]
        </li>
        <li>
         <strong>
          Output:
         </strong>
         After processing the data, the computer needs a way to communicate the results back to the user. Output devices convert the computer's binary data back into a human-understandable form, such as text on a screen, printed paper, or sound.
        </li>
       </ol>
       <p>
        <strong>
         Common I/O Devices:
        </strong>
       </p>
       <ul>
        <li>
         <strong>
          Input Devices:
         </strong>
         Keyboard, Mouse, Scanner, Microphone, Webcam, Touchscreen.
        </li>
        <li>
         <strong>
          Output Devices:
         </strong>
         Monitor, Printer, Speakers, Projector, Headphones.
        </li>
        <li>
         <strong>
          Devices that are both Input and Output:
         </strong>
         Touchscreen, Network Interface Card (NIC), External Hard Drive.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        5. What is FPU? How does it differ from ALU?
       </h4>
       <p>
        An FPU, or Floating-Point Unit, is a specialized part of a computer's processor designed specifically to perform arithmetic operations on floating-point numbers (real numbers with decimal points).[14]
       </p>
       <p>
        The primary difference between an FPU and an ALU (Arithmetic Logic Unit) lies in the type of data they are designed to process [15, 16]:
       </p>
       <ul>
        <li>
         <strong>
          ALU (Arithmetic Logic Unit):
         </strong>
         The ALU is a fundamental component of the CPU that handles arithmetic and bitwise logical operations on
         <strong>
          integers
         </strong>
         (whole numbers) and binary data. Its operations include addition, subtraction, AND, OR, NOT, and bit-shifting.[15] It is a general-purpose calculation unit.
        </li>
        <li>
         <strong>
          FPU (Floating-Point Unit):
         </strong>
         The FPU is a specialized co-processor that handles complex mathematical operations on
         <strong>
          floating-point numbers
         </strong>
         . These operations, such as multiplication, division, and square roots on non-integer values, are crucial for scientific, engineering, and graphics applications. Performing these calculations in a dedicated FPU is significantly faster and more efficient than emulating them in software using the ALU.[14]
        </li>
       </ul>
       <p>
        In summary, the ALU handles integer and logical operations, while the FPU handles operations on real numbers (decimals).
       </p>
      </article>
     </section>
     <section id="storage-and-memory">
      <h3>
       b. Storage and Memory
      </h3>
      <article>
       <h4>
        1. Distinguish between Primary and Secondary memory.
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Basis of Comparison
          </th>
          <th>
           Primary Memory
          </th>
          <th>
           Secondary Memory
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Also Known As
           </strong>
          </td>
          <td>
           Main Memory, Internal Memory
          </td>
          <td>
           Auxiliary Memory, External Memory
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Volatility
           </strong>
          </td>
          <td>
           Typically volatile (loses data on power off)
          </td>
          <td>
           Non-volatile (retains data without power)
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Access Speed
           </strong>
          </td>
          <td>
           Very fast
          </td>
          <td>
           Slower than primary memory
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Cost per Bit
           </strong>
          </td>
          <td>
           High
          </td>
          <td>
           Low
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Capacity
           </strong>
          </td>
          <td>
           Smaller capacity
          </td>
          <td>
           Larger capacity
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            CPU Accessibility
           </strong>
          </td>
          <td>
           Directly accessible by the CPU
          </td>
          <td>
           Not directly accessible; data is first moved to primary memory
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Examples
           </strong>
          </td>
          <td>
           RAM (Random Access Memory), Cache Memory, ROM
          </td>
          <td>
           Hard Disk Drive (HDD), Solid State Drive (SSD), CD/DVD, USB Drive
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        2. Explain the difference between volatile and non-volatile memory. Give an example of each type of memory.
       </h4>
       <p>
        The fundamental difference between volatile and non-volatile memory is its ability to retain data when power is removed.
       </p>
       <ul>
        <li>
         <strong>
          Volatile Memory:
         </strong>
         This type of memory requires a constant power supply to maintain the stored information. If the power is interrupted or turned off, all data stored in it is lost. It is generally used for temporary storage of data that the CPU is actively working on because of its high speed.
         <ul>
          <li>
           <strong>
            Example:
           </strong>
           RAM (Random Access Memory).
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Non-Volatile Memory:
         </strong>
         This type of memory can retain stored information even after the power is turned off. It is used for long-term storage of the operating system, applications, and user files.
         <ul>
          <li>
           <strong>
            Example:
           </strong>
           ROM (Read-Only Memory), Hard Disk Drive (HDD), Solid State Drive (SSD), Flash Drives.
          </li>
         </ul>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. Define RAM and ROM.
       </h4>
       <ul>
        <li>
         <strong>
          RAM (Random Access Memory):
         </strong>
         RAM is a form of volatile computer memory that can be read from and written to. It is used by the CPU to store data and program instructions that are currently in use. Because it is volatile, its contents are lost when the computer is turned off. Its "random access" nature means that any byte of memory can be accessed directly without touching the preceding bytes, making it very fast.
        </li>
        <li>
         <strong>
          ROM (Read-Only Memory):
         </strong>
         ROM is a type of non-volatile memory from which data can typically only be read, not written to (or written to with difficulty). It is used to store firmware—software that is closely tied to specific hardware and is unlikely to need frequent updates, such as the computer's BIOS or UEFI, which contains the initial instructions for booting the computer.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        4. Why is RAM called "Random" Access Memory? How is it different from hard disk? Briefly discuss. / Why RAM is called primary memory? Briefly describe.
       </h4>
       <p>
        RAM is called "Random" Access Memory because any memory location (or address) within it can be accessed directly in a very short and nearly constant amount of time, regardless of its physical position. This is in contrast to sequential access memory (like old magnetic tapes), where data must be read in the order it was stored.
       </p>
       <h5>
        Difference from Hard Disk:
       </h5>
       <p>
        The primary differences between RAM and a hard disk are speed, volatility, and access method.
       </p>
       <ul>
        <li>
         <strong>
          Speed &amp; Access:
         </strong>
         RAM is electronic (solid-state) and allows for direct, random access, making it thousands of times faster than a hard disk. A hard disk is an electromechanical device that involves physically moving read/write heads over spinning magnetic platters, which introduces significant latency (seek time and rotational delay).
        </li>
        <li>
         <strong>
          Volatility:
         </strong>
         RAM is volatile, losing its data when power is off. A hard disk is non-volatile, retaining data permanently.
        </li>
       </ul>
       <h5>
        Why RAM is called Primary Memory:
       </h5>
       <p>
        RAM is called primary memory because it is the main working memory of the computer that is directly accessible by the CPU. The CPU can only execute programs and process data that are loaded into primary memory. All data from input devices and secondary storage must be brought into RAM before the CPU can work with it.
       </p>
      </article>
      <article>
       <h4>
        5. What is Cache memory? Why is it so fast?
       </h4>
       <p>
        Cache memory is a small, extremely fast, and expensive type of volatile memory that is located between the CPU and the main memory (RAM). Its purpose is to store frequently accessed data and instructions from RAM, allowing the CPU to retrieve them much more quickly than if it had to go to RAM every time.
       </p>
       <p>
        Cache memory is so fast for two main reasons:
       </p>
       <ol>
        <li>
         <strong>
          Proximity to the CPU:
         </strong>
         Cache is physically located closer to the CPU core, often on the same chip. This reduces the physical distance data has to travel, significantly lowering latency compared to accessing the separate RAM chips on the motherboard.
        </li>
        <li>
         <strong>
          Technology Used:
         </strong>
         Cache memory is typically built using SRAM (Static RAM) technology. SRAM is much faster than the DRAM (Dynamic RAM) used for main memory because it uses a latching circuit (flip-flops) to store each bit and does not need to be constantly refreshed. DRAM, in contrast, uses a capacitor that leaks charge and must be refreshed thousands of times per second, which slows it down.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        6. How does 3-level cache organization work between CPU and main memory? Explain with proper diagram briefly. / Why is cached used? Explain the three level cache organizations between CPU and main memory.
       </h4>
       <p>
        Cache is used to bridge the significant speed gap between the very fast CPU and the relatively slow main memory (RAM). By storing frequently used data closer to the CPU, it reduces the average memory access time and improves overall system performance.
       </p>
       <p>
        A 3-level cache organization is a hierarchy of caches with different sizes and speeds:
       </p>
       <ul>
        <li>
         <strong>
          Level 1 (L1) Cache:
         </strong>
         This is the smallest and fastest cache, located directly on the CPU core. It is often split into an L1 instruction cache (for instructions) and an L1 data cache (for data). When the CPU needs data, it checks the L1 cache first.
        </li>
        <li>
         <strong>
          Level 2 (L2) Cache:
         </strong>
         If the data is not found in L1 (an "L1 miss"), the CPU checks the L2 cache. L2 is larger but slightly slower than L1. It can be private to each CPU core or shared between a few cores.
        </li>
        <li>
         <strong>
          Level 3 (L3) Cache:
         </strong>
         If the data is not in L2 (an "L2 miss"), the CPU checks the L3 cache. L3 is the largest and slowest of the three caches but is still much faster than RAM. It is typically shared among all cores on a single processor chip.
        </li>
       </ul>
       <p>
        Process Flow:
        <br/>
        CPU Request → Check L1 Cache → (if miss) Check L2 Cache → (if miss) Check L3 Cache → (if miss) Fetch from Main Memory (RAM).
        <br/>
        When data is fetched from RAM, a copy is placed in all levels of the cache so that subsequent requests for the same data can be served much faster.
       </p>
      </article>
      <article>
       <h4>
        7. Describe how data is stored in (i) Hard disk drive, (ii) CD/DVD ROM.
       </h4>
       <h5>
        (i) Hard Disk Drive (HDD):
       </h5>
       <p>
        An HDD is a magnetic storage device. Data is stored on a series of flat, circular platters coated with a magnetic material. These platters spin at high speeds (e.g., 7200 RPM). A read/write head, attached to an actuator arm, moves across the surface of the spinning platters. Data is stored by magnetizing tiny spots on the platters in a specific direction to represent binary 0s and 1s. To read the data, the head detects the magnetic orientation of these spots.
       </p>
       <h5>
        (ii) CD/DVD ROM:
       </h5>
       <p>
        A CD/DVD is an optical storage device. Data is stored as a series of microscopic indentations, called "pits," and flat areas, called "lands," on a reflective polycarbonate layer. This data track spirals outwards from the center of the disc. A low-powered laser beam inside the drive reads the disc. As the disc spins, the laser reflects off the surface. The light reflects differently from a pit than from a land, and a sensor detects these changes in reflectivity, converting them into the binary data of 0s and 1s.
       </p>
      </article>
      <article>
       <h4>
        8. Which one is faster- SRAM cell or DRAM cell? Explain with appropriate circuit diagrams.
       </h4>
       <p>
        The SRAM (Static RAM) cell is significantly faster than the DRAM (Dynamic RAM) cell.
       </p>
       <p>
        The reason for the speed difference lies in their fundamental design:
       </p>
       <ul>
        <li>
         <strong>
          SRAM Cell:
         </strong>
         An SRAM cell uses a flip-flop circuit, typically composed of 6 transistors (6T SRAM), to store a single bit. This circuit acts as a latch, holding its state (0 or 1) as long as power is supplied. It does not require refreshing. Access is very fast because the state can be read directly from the stable latch.
        </li>
        <li>
         <strong>
          DRAM Cell:
         </strong>
         A DRAM cell is much simpler, consisting of a single transistor and a single capacitor. The bit is stored as an electrical charge on the capacitor (charged = 1, discharged = 0). Because the capacitor naturally leaks its charge over time, the cell must be periodically read and rewritten (refreshed) hundreds of times per second to retain its data. This refresh cycle, along with the time it takes to charge/discharge the capacitor, makes DRAM slower than SRAM.
        </li>
       </ul>
       <p>
        Since diagrams cannot be drawn, the circuits are described textually.
       </p>
      </article>
      <article>
       <h4>
        9. Draw the block diagram of a 6-transistor SRAM cell.
       </h4>
       <p>
        A 6-transistor (6T) SRAM cell consists of two main parts:
       </p>
       <ol>
        <li>
         <strong>
          The Storage Latch:
         </strong>
         This is the core of the cell, formed by two cross-coupled CMOS inverters. Each inverter is made of two transistors (a PMOS and an NMOS). These two inverters (total of 4 transistors) form a bistable latch that stores one bit of data (either a 0 or a 1).
        </li>
        <li>
         <strong>
          The Access Transistors:
         </strong>
         Two additional NMOS transistors act as switches, connecting the latch to two bit lines (BL and BL-bar). These access transistors are controlled by the word line (WL). When the word line is activated (high), the switches close, allowing the cell to be read from or written to via the bit lines. When the word line is low, the cell is isolated and retains its data.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        10. Mention the significance of memory in embedded programming.
       </h4>
       <p>
        Memory is highly significant and a critical constraint in embedded programming for several reasons:
       </p>
       <ol>
        <li>
         <strong>
          Resource Constraints:
         </strong>
         Embedded systems (like those in microwaves, robots, or IoT devices) are often designed with a minimal amount of RAM and ROM to reduce cost, power consumption, and physical size. Programmers must write highly efficient code to fit within these tight memory limits.
        </li>
        <li>
         <strong>
          Performance:
         </strong>
         Direct memory access is often required for real-time performance. C and C++ are popular in embedded systems because they allow for low-level memory manipulation through pointers, which can be used to directly control hardware registers and peripherals.
        </li>
        <li>
         <strong>
          Reliability:
         </strong>
         In many embedded applications (e.g., automotive or medical devices), system failure is not an option. Proper memory management is crucial to prevent issues like stack overflows or memory leaks that could crash the system.
        </li>
        <li>
         <strong>
          Memory-Mapped I/O:
         </strong>
         In embedded systems, hardware control registers are often mapped directly into the memory address space. Programming involves reading from and writing to specific memory addresses to configure and control hardware components like sensors and motors.
        </li>
       </ol>
      </article>
     </section>
     <section id="number-systems">
      <h3>
       c. Number Systems
      </h3>
      <article>
       <h4>
        1. Convert the following numbers to decimal number system: i) ii) iii).
       </h4>
       <p>
        (Note: The specific numbers were not provided in the prompt, but the method is demonstrated below for example binary, octal, and hexadecimal numbers.)
       </p>
       <ul>
        <li>
         Example Binary to Decimal: Convert (1101.101)
         <sub>
          2
         </sub>
         to decimal.
         <br/>
         1×2
         <sup>
          3
         </sup>
         +1×2
         <sup>
          2
         </sup>
         +0×2
         <sup>
          1
         </sup>
         +1×2
         <sup>
          0
         </sup>
         +1×2
         <sup>
          -1
         </sup>
         +0×2
         <sup>
          -2
         </sup>
         +1×2
         <sup>
          -3
         </sup>
         <br/>
         = 8+4+0+1+0.5+0+0.125 = (13.625)
         <sub>
          10
         </sub>
        </li>
        <li>
         Example Octal to Decimal: Convert (72.4)
         <sub>
          8
         </sub>
         to decimal.
         <br/>
         7×8
         <sup>
          1
         </sup>
         +2×8
         <sup>
          0
         </sup>
         +4×8
         <sup>
          -1
         </sup>
         <br/>
         = 56+2+0.5 = (58.5)
         <sub>
          10
         </sub>
        </li>
        <li>
         Example Hexadecimal to Decimal: Convert (B6A)
         <sub>
          16
         </sub>
         to decimal.
         <br/>
         11×16
         <sup>
          2
         </sup>
         +6×16
         <sup>
          1
         </sup>
         +10×16
         <sup>
          0
         </sup>
         <br/>
         = 11×256+6×16+10×1
         <br/>
         = 2816+96+10 = (2922)
         <sub>
          10
         </sub>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        2. Convert to its corresponding hexadecimal number.
       </h4>
       <p>
        (Note: The specific number was not provided. The method is demonstrated for a binary number.)
       </p>
       <ul>
        <li>
         <strong>
          Example Binary to Hexadecimal:
         </strong>
         Convert to hexadecimal.
         <ol>
          <li>
           Group the bits into sets of four, starting from the decimal point. Add leading/trailing zeros if needed.
           <br/>
           Integer part: 0011 1010 1100
           <br/>
           Fractional part: 0110 1000
          </li>
          <li>
           Convert each 4-bit group to its hexadecimal equivalent.
           <br/>
           0011 = 3
           <br/>
           1010 = A
           <br/>
           1100 = C
           <br/>
           0110 = 6
           <br/>
           1000 = 8
          </li>
          <li>
           Combine the results.
           <br/>
           Result: (3AC.68)
           <sub>
            16
           </sub>
          </li>
         </ol>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. Write a computer program to convert a decimal number to its binary equivalents. / Write a C program to convert a binary number into a decimal number.
       </h4>
       <h5>
        C Program: Decimal to Binary Conversion
       </h5>
       <pre><code>
#include <stdio.h>

void decimalToBinary(int n) {
    if (n == 0) {
        printf("0");
        return;
    }
    long long binaryNum = 0;
    int remainder, i = 1;
    while (n != 0) {
        remainder = n % 2;
        n /= 2;
        binaryNum += remainder * i;
        i *= 10;
    }
    printf("%lld", binaryNum);
}

int main() {
    int decimalNum;
    printf("Enter a decimal number: ");
    scanf("%d", &amp;decimalNum);
    printf("Binary equivalent: ");
    decimalToBinary(decimalNum);
    printf("\\n");
    return 0;
}
                    </stdio.h></code></pre>
       <h5>
        C Program: Binary to Decimal Conversion
       </h5>
       <pre><code>
#include <stdio.h>
#include <math.h>

int binaryToDecimal(long long n) {
    int decimalNum = 0, i = 0, remainder;
    while (n != 0) {
        remainder = n % 10;
        n /= 10;
        decimalNum += remainder * pow(2, i);
        ++i;
    }
    return decimalNum;
}

int main() {
    long long binaryNum;
    printf("Enter a binary number: ");
    scanf("%lld", &amp;binaryNum);
    printf("Decimal equivalent: %d\\n", binaryToDecimal(binaryNum));
    return 0;
}
                    </math.h></stdio.h></code></pre>
      </article>
      <article>
       <h4>
        4. Find the 2's complement of following numbers: (i) 255 (ii) 0 (iii) 105.
       </h4>
       <p>
        (Assuming an 8-bit representation for positive numbers and a 9-bit result for 255 to avoid overflow issues, and 8-bit for the others.)
       </p>
       <p>
        To find the 2's complement of a positive number (which represents its negative equivalent):
       </p>
       <ol>
        <li>
         Convert the number to binary.
        </li>
        <li>
         Invert all the bits (1's complement).
        </li>
        <li>
         Add 1 to the result.
        </li>
       </ol>
       <p>
        <strong>
         (i) 255:
        </strong>
       </p>
       <ul>
        <li>
         In 8 bits, 255 is 11111111. The 2's complement representation of -255 requires at least 9 bits. Let's find the 2's complement of -1 using the 8-bit representation of 255.
        </li>
        <li>
         To represent -255, we need more bits. Let's find the 2's complement of a smaller number, e.g.,
         <strong>
          -101
         </strong>
         (using 8 bits).
         <ol>
          <li>
           Binary of 101: 01100101
          </li>
          <li>
           1's complement: 10011010
          </li>
          <li>
           Add 1: 10011011. So, 2's complement of -101 is 10011011.
          </li>
         </ol>
        </li>
       </ul>
       <p>
        <strong>
         (ii) 0:
        </strong>
       </p>
       <ol>
        <li>
         Binary of 0 (8 bits): 00000000
        </li>
        <li>
         1's complement: 11111111
        </li>
        <li>
         Add 1: 11111111 + 1 = 100000000. Discarding the overflow bit, the result is 00000000. The 2's complement of 0 is 0.
        </li>
       </ol>
       <p>
        <strong>
         (iii) 105:
        </strong>
       </p>
       <ul>
        <li>
         To find the 2's complement representation of
         <strong>
          -105
         </strong>
         (using 8 bits):
         <ol>
          <li>
           Binary of 105: 01101001
          </li>
          <li>
           1's complement: 10010110
          </li>
          <li>
           Add 1: 10010111. So, 2's complement of -105 is 10010111.
          </li>
         </ol>
        </li>
       </ul>
      </article>
      <article>
       <h4>
        5. Write the next four numbers in this hex counting sequence: E9A, E9B, E9C, E9D, _,_,_,_
       </h4>
       <p>
        The sequence is counting up in hexadecimal. After D comes E, then F. After F, the next digit rolls over.
       </p>
       <ul>
        <li>
         E9D + 1 = E9E
        </li>
        <li>
         E9E + 1 = E9F
        </li>
        <li>
         E9F + 1 = EA0 (F rolls over to 0, and the next digit 9 increments to A)
        </li>
        <li>
         EA0 + 1 = EA1
        </li>
       </ul>
       <p>
        The next four numbers are:
        <strong>
         E9E, E9F, EA0, EA1
        </strong>
        .
       </p>
      </article>
      <article>
       <h4>
        6. Why computer uses binary number system instead of decimal? Explain.
       </h4>
       <p>
        Computers use the binary number system because their fundamental building blocks, transistors, operate most reliably as simple switches. A switch has two stable states: ON or OFF. These two states can be naturally and efficiently represented by the two digits of the binary system: 1 (ON) and 0 (OFF).
       </p>
       <p>
        While it is technically possible to build electronic circuits that can represent ten different states for the decimal system, such circuits would be far more complex, expensive, and susceptible to errors from electrical noise or voltage fluctuations. The simplicity and reliability of the two-state binary system make it the ideal choice for designing and building digital computer hardware.
       </p>
      </article>
     </section>
     <section id="algorithms-and-flowcharts">
      <h3>
       d. Algorithms and Flowcharts
      </h3>
      <article>
       <h4>
        1. Write down an algorithm to add 2 numbers from user. Draw the corresponding flow chart.
       </h4>
       <h5>
        Algorithm:
       </h5>
       <ol>
        <li>
         START
        </li>
        <li>
         Declare three variables: num1, num2, and sum.
        </li>
        <li>
         Prompt the user to enter the first number.
        </li>
        <li>
         Read the first number and store it in num1.
        </li>
        <li>
         Prompt the user to enter the second number.
        </li>
        <li>
         Read the second number and store it in num2.
        </li>
        <li>
         Calculate the sum: sum = num1 + num2.
        </li>
        <li>
         Display the value of sum.
        </li>
        <li>
         STOP
        </li>
       </ol>
       <h5>
        Flowchart Description:
       </h5>
       <ol>
        <li>
         An oval shape labeled "START".
        </li>
        <li>
         An arrow points to a parallelogram labeled "Input num1, num2".
        </li>
        <li>
         An arrow points to a rectangle labeled "Calculate sum = num1 + num2".
        </li>
        <li>
         An arrow points to a parallelogram labeled "Display sum".
        </li>
        <li>
         An arrow points to an oval shape labeled "STOP".
        </li>
       </ol>
      </article>
      <article>
       <h4>
        2. Design an algorithm as well as flowchart for finding out largest number out of three given numbers.
       </h4>
       <h5>
        Algorithm:
       </h5>
       <ol>
        <li>
         START
        </li>
        <li>
         Declare four variables: a, b, c, and largest.
        </li>
        <li>
         Read the three numbers a, b, and c.
        </li>
        <li>
         Check if a &gt;= b AND a &gt;= c.
        </li>
        <li>
         If true, set largest = a.
        </li>
        <li>
         Else, check if b &gt;= a AND b &gt;= c.
        </li>
        <li>
         If true, set largest = b.
        </li>
        <li>
         Else, set largest = c.
        </li>
        <li>
         Display the value of largest.
        </li>
        <li>
         STOP
        </li>
       </ol>
       <h5>
        Flowchart Description:
       </h5>
       <ol>
        <li>
         Oval: "START".
        </li>
        <li>
         Parallelogram: "Input a, b, c".
        </li>
        <li>
         Diamond: "Is a &gt;= b AND a &gt;= c?".
        </li>
        <li>
         From the "Yes" branch of the diamond, an arrow points to a rectangle: "largest = a". This then points to the display step.
        </li>
        <li>
         From the "No" branch of the first diamond, an arrow points to a second diamond: "Is b &gt;= a AND b &gt;= c?".
        </li>
        <li>
         From the "Yes" branch of the second diamond, an arrow points to a rectangle: "largest = b". This then points to the display step.
        </li>
        <li>
         From the "No" branch of the second diamond, an arrow points to a rectangle: "largest = c".
        </li>
        <li>
         All three paths converge on a parallelogram: "Display largest".
        </li>
        <li>
         An arrow points to an oval: "STOP".
        </li>
       </ol>
      </article>
      <article>
       <h4>
        3. Write an algorithm to convert a given number of days into year, month and days. Draw the corresponding flowchart.
       </h4>
       <h5>
        Algorithm:
       </h5>
       <ol>
        <li>
         START
        </li>
        <li>
         Declare variables: total_days, years, months, days.
        </li>
        <li>
         Read the value of total_days.
        </li>
        <li>
         Calculate years: years = total_days / 365.
        </li>
        <li>
         Update remaining days: total_days = total_days % 365.
        </li>
        <li>
         Calculate months: months = total_days / 30.
        </li>
        <li>
         Calculate final days: days = total_days % 30.
        </li>
        <li>
         Display the values of years, months, and days.
        </li>
        <li>
         STOP
        </li>
       </ol>
       <h5>
        Flowchart Description:
       </h5>
       <ol>
        <li>
         Oval: "START".
        </li>
        <li>
         Parallelogram: "Input total_days".
        </li>
        <li>
         Rectangle: "years = total_days / 365".
        </li>
        <li>
         Rectangle: "total_days = total_days % 365".
        </li>
        <li>
         Rectangle: "months = total_days / 30".
        </li>
        <li>
         Rectangle: "days = total_days % 30".
        </li>
        <li>
         Parallelogram: "Display years, months, days".
        </li>
        <li>
         Oval: "STOP".
        </li>
       </ol>
      </article>
      <article>
       <h4>
        4. Draw a flowchart to find whether a number is prime or not.
       </h4>
       <h5>
        Flowchart Description:
       </h5>
       <ol>
        <li>
         Oval: "START".
        </li>
        <li>
         Parallelogram: "Input number n".
        </li>
        <li>
         Rectangle: "Set isPrime = 1, i = 2". (isPrime is a flag, 1 for true).
        </li>
        <li>
         Diamond: "Is n &lt;= 1?".
        </li>
        <li>
         From "Yes" branch, rectangle: "isPrime = 0". Then go to step 9.
        </li>
        <li>
         From "No" branch, diamond: "Is i &lt;= n / 2?".
        </li>
        <li>
         From "No" branch of this diamond, go to step 9.
        </li>
        <li>
         From "Yes" branch, diamond: "Is n % i == 0?".
         <ol type="a">
          <li>
           From "Yes" branch, rectangle: "isPrime = 0". Then arrow to a rectangle: "break" (or directly to step 9).
          </li>
          <li>
           From "No" branch, rectangle: "i = i + 1". Then arrow loops back to the diamond at step 6.
          </li>
         </ol>
        </li>
        <li>
         Diamond: "Is isPrime == 1?".
        </li>
        <li>
         From "Yes" branch, parallelogram: "Display 'n is Prime'".
        </li>
        <li>
         From "No" branch, parallelogram: "Display 'n is not Prime'".
        </li>
        <li>
         Both paths converge to an oval: "STOP".
        </li>
       </ol>
      </article>
      <article>
       <h4>
        5. Write an algorithm for finding the largest number from an array, without using loop. / Define Algorithm. Write an algorithm to find leap year.
       </h4>
       <p>
        Algorithm:
        <br/>
        An algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of problems or to perform a computation.
       </p>
       <h5>
        Algorithm for finding the largest number from an array (using recursion, without an explicit loop):
       </h5>
       <ol>
        <li>
         START
        </li>
        <li>
         Define a function findMax(array, index, length).
        </li>
        <li>
         <strong>
          Base Case:
         </strong>
         If index == length - 1, return array[index].
        </li>
        <li>
         <strong>
          Recursive Step:
         </strong>
         Call maxOfRest = findMax(array, index + 1, length).
        </li>
        <li>
         Compare array[index] with maxOfRest.
        </li>
        <li>
         If array[index] &gt; maxOfRest, return array[index].
        </li>
        <li>
         Else, return maxOfRest.
        </li>
        <li>
         In the main part of the algorithm, call findMax(myArray, 0, arrayLength) and display the result.
        </li>
        <li>
         STOP
        </li>
       </ol>
       <h5>
        Algorithm to find leap year:
       </h5>
       <ol>
        <li>
         START
        </li>
        <li>
         Declare variable year.
        </li>
        <li>
         Read the value of year.
        </li>
        <li>
         Check if (year is divisible by 400) OR (year is divisible by 4 AND year is not divisible by 100).
         <ul>
          <li>
           In logical terms: if ((year % 400 == 0) || (year % 4 == 0 &amp;&amp; year % 100 != 0))
          </li>
         </ul>
        </li>
        <li>
         If the condition in step 4 is true, display "year is a Leap Year".
        </li>
        <li>
         Else, display "year is not a Leap Year".
        </li>
        <li>
         STOP
        </li>
       </ol>
      </article>
     </section>
     <section id="programming-language-levels">
      <h3>
       e. Programming Language Levels
      </h3>
      <article>
       <h4>
        1. What are the differences between high-level and low-level languages?
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Feature
          </th>
          <th>
           High-Level Language (HLL)
          </th>
          <th>
           Low-Level Language (LLL)
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Abstraction
           </strong>
          </td>
          <td>
           High level of abstraction from hardware.
          </td>
          <td>
           Little to no abstraction from hardware.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Human Readability
           </strong>
          </td>
          <td>
           Easy to read, write, and understand (e.g., Python, Java).
          </td>
          <td>
           Difficult to read and understand (e.g., Assembly, Machine Code).
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Portability
           </strong>
          </td>
          <td>
           Highly portable; can run on different machine architectures.
          </td>
          <td>
           Machine-dependent; not portable.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Execution Speed
           </strong>
          </td>
          <td>
           Generally slower due to translation overhead.
          </td>
          <td>
           Very fast execution as it is closer to the hardware.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Memory Management
           </strong>
          </td>
          <td>
           Often managed automatically (e.g., garbage collection).
          </td>
          <td>
           Requires manual memory management by the programmer.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Ease of Debugging
           </strong>
          </td>
          <td>
           Easier to debug.
          </td>
          <td>
           Difficult and time-consuming to debug.
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        2. Explain the machine language and assembly language.
       </h4>
       <ul>
        <li>
         <strong>
          Machine Language:
         </strong>
         This is the lowest-level programming language, consisting of binary digits (0s and 1s). It is the only language that a computer's CPU can directly understand and execute. Each instruction in machine language corresponds to a specific operation the CPU can perform. It is extremely difficult for humans to read or write.
        </li>
        <li>
         <strong>
          Assembly Language:
         </strong>
         This is a low-level language that provides a symbolic representation of machine language instructions. It uses mnemonics (short, English-like words) like MOV, ADD, SUB to represent machine code operations, making it more readable than binary. An assembler program is required to translate assembly code into machine code. While easier than machine language, it is still hardware-dependent and requires a deep understanding of the computer's architecture.
        </li>
       </ul>
      </article>
      <article>
       <h4>
        3. Explain "Assembly languages are difficult to code complex logics compared to high level languages".
       </h4>
       <p>
        This statement is true because assembly language lacks the high-level abstractions that simplify complex programming.
       </p>
       <ol>
        <li>
         <strong>
          Lack of Control Structures:
         </strong>
         High-level languages provide built-in constructs like if-else, for, and while loops. In assembly, these must be manually constructed using conditional jumps (JMP, JE) and labels, which is tedious and error-prone for complex logic.
        </li>
        <li>
         <strong>
          Manual Resource Management:
         </strong>
         The programmer must manually manage CPU registers, memory allocation, and the call stack. This adds a significant layer of complexity compared to high-level languages where the compiler or runtime handles these details.
        </li>
        <li>
         <strong>
          Verbosity:
         </strong>
         A single, simple operation in a high-level language (e.g., c = a + b) can translate into multiple lines of assembly code (load a into a register, load b into another, add them, store the result). This verbosity makes the overall program structure for complex logic very difficult to follow.
        </li>
        <li>
         <strong>
          No Data Structures:
         </strong>
         High-level languages have built-in support for complex data structures like arrays, structs, and objects. In assembly, these must be implemented from scratch using basic memory addressing.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        4. "C is a mid level language". Explain.
       </h4>
       <p>
        C is often called a middle-level language because it bridges the gap between high-level and low-level languages. It provides features of both, offering a unique balance of power and abstraction.
       </p>
       <ul>
        <li>
         <strong>
          High-Level Features:
         </strong>
         C includes high-level constructs that make programming easier and more structured, such as functions, loops (for, while), decision-making statements (if, switch), and data structures (struct).
        </li>
        <li>
         <strong>
          Low-Level Features:
         </strong>
         C also provides direct access to the system's memory through pointers. It allows for pointer arithmetic, bitwise manipulation, and direct interaction with hardware addresses. These are features typically found in low-level languages like assembly and are essential for system programming, driver development, and embedded systems.
        </li>
       </ul>
       <p>
        This combination allows programmers to write efficient, high-performance code with fine-grained control over hardware, while still benefiting from the readability and structure of a high-level language.
       </p>
      </article>
      <article>
       <h4>
        5. What are the parameters for choosing a programming language?
       </h4>
       <p>
        The choice of a programming language for a project depends on several critical parameters:
       </p>
       <ol>
        <li>
         <strong>
          Problem Domain:
         </strong>
         The nature of the application is paramount. For web development, languages like JavaScript or Python are common. For scientific computing, Fortran or Python with libraries like NumPy are used. For systems programming, C or C++ is preferred.
        </li>
        <li>
         <strong>
          Performance Requirements:
         </strong>
         If the application requires high speed and efficiency (e.g., game engines, operating systems), languages like C++ or Rust are chosen. For applications where development speed is more critical, interpreted languages like Python or Ruby may be better.
        </li>
        <li>
         <strong>
          Platform/Target Environment:
         </strong>
         The language must be compatible with the target operating system (Windows, macOS, Linux) or hardware (e.g., embedded microcontrollers).
        </li>
        <li>
         <strong>
          Ecosystem and Libraries:
         </strong>
         The availability of robust libraries, frameworks, and tools can significantly speed up development.
        </li>
        <li>
         <strong>
          Developer Expertise and Team Skills:
         </strong>
         The team's familiarity with a language is a major factor in productivity and code quality.
        </li>
        <li>
         <strong>
          Scalability and Maintainability:
         </strong>
         The language should support writing code that is easy to maintain, debug, and scale as the project grows.
        </li>
        <li>
         <strong>
          Community Support:
         </strong>
         A large and active community ensures better documentation, help with problem-solving, and a steady supply of updated tools.
        </li>
       </ol>
      </article>
     </section>
     <section id="language-translators">
      <h3>
       f. Language Translators
      </h3>
      <article>
       <h4>
        1. Describe the differences between compiler and interpreter. / Differentiate between compiler and interpreter. / Distinguish between compiler and interpreter.
       </h4>
       <table>
        <thead>
         <tr>
          <th>
           Basis of Comparison
          </th>
          <th>
           Compiler
          </th>
          <th>
           Interpreter
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           <strong>
            Translation Process
           </strong>
          </td>
          <td>
           Translates the entire source code into machine code at once, before execution.
          </td>
          <td>
           Translates and executes the source code line-by-line.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Output
           </strong>
          </td>
          <td>
           Creates a standalone executable file (object code).
          </td>
          <td>
           Does not produce an executable file.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Execution Speed
           </strong>
          </td>
          <td>
           Faster, because the code is already translated into machine code.
          </td>
          <td>
           Slower, because translation happens during execution for each line.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Error Reporting
           </strong>
          </td>
          <td>
           Reports all syntax errors at the end of the compilation process.
          </td>
          <td>
           Reports the first error it encounters and stops execution.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Platform Dependency
           </strong>
          </td>
          <td>
           The generated object code is specific to a machine architecture.
          </td>
          <td>
           More portable, as the source code can run on any machine with the interpreter installed.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Requirement
           </strong>
          </td>
          <td>
           The compiler is only needed during the development phase.
          </td>
          <td>
           The interpreter must be present on the target machine every time the program is run.
          </td>
         </tr>
         <tr>
          <td>
           <strong>
            Examples
           </strong>
          </td>
          <td>
           C, C++, Java (compiles to bytecode)
          </td>
          <td>
           Python, JavaScript, Ruby
          </td>
         </tr>
        </tbody>
       </table>
      </article>
      <article>
       <h4>
        2. Distinguish between Source code &amp; Object code. / Define source code and object code. / What is a source Program? An object program? Why are these concepts important?
       </h4>
       <ul>
        <li>
         <strong>
          Source Code (Source Program):
         </strong>
         This is the program code written by a human programmer in a high-level or assembly language. It is human-readable and consists of text, instructions, and comments. For example, a .c file contains source code.
        </li>
        <li>
         <strong>
          Object Code (Object Program):
         </strong>
         This is the machine-readable code produced by a compiler or an assembler after translating the source code. It consists of binary or low-level instructions that the CPU can understand. It is not easily readable by humans. For example, a .o or .obj file contains object code.
        </li>
       </ul>
       <p>
        Importance:
        <br/>
        These concepts are fundamental to the process of software development. The distinction represents the translation from a human-friendly abstraction (source code) to a machine-executable reality (object code). This separation allows programmers to work in powerful, abstract languages without needing to know the intricate details of the underlying hardware. The object code is what is ultimately linked with libraries to create a final executable program.
       </p>
      </article>
      <article>
       <h4>
        3. What is compiler? Explain the front-end and back-end phases of compiler in brief.
       </h4>
       <p>
        A compiler is a special program that translates source code written in a high-level programming language (like C++ or Java) into a lower-level language (like assembly or machine code), creating an executable program.
       </p>
       <p>
        The compilation process is broadly divided into two main phases:
       </p>
       <ol>
        <li>
         <strong>
          Front-End (Analysis Phase):
         </strong>
         This phase deals with the source language. It reads the source code, checks it for syntactic and semantic correctness, and generates an intermediate representation (IR) of the code. It is independent of the target machine. Its main stages are:
         <ul>
          <li>
           <strong>
            Lexical Analysis:
           </strong>
           Breaks the source code into a stream of tokens (keywords, identifiers, etc.).
          </li>
          <li>
           <strong>
            Syntax Analysis (Parsing):
           </strong>
           Checks if the tokens form a valid sequence according to the language's grammar and builds a parse tree.
          </li>
          <li>
           <strong>
            Semantic Analysis:
           </strong>
           Checks for logical errors, such as type mismatches.
          </li>
         </ul>
        </li>
        <li>
         <strong>
          Back-End (Synthesis Phase):
         </strong>
         This phase takes the intermediate representation from the front-end and generates the target machine code. It is dependent on the target machine's architecture. Its main stages are:
         <ul>
          <li>
           <strong>
            Code Optimization:
           </strong>
           Improves the intermediate code to make the final program faster and more memory-efficient.
          </li>
          <li>
           <strong>
            Code Generation:
           </strong>
           Translates the optimized intermediate code into the target machine language.
          </li>
         </ul>
        </li>
       </ol>
      </article>
      <article>
       <h4>
        4. "Interpreter is a program that can execute high level language programs directly." Explain this statement.
       </h4>
       <p>
        This statement is a common simplification. An interpreter does not allow the hardware to execute high-level language programs "directly." The CPU can only execute machine code.
       </p>
       <p>
        What the statement means is that an interpreter
        <strong>
         interleaves translation and execution
        </strong>
        , giving the appearance of direct execution. The process is as follows:
       </p>
       <ol>
        <li>
         The interpreter, which is itself an executable program, reads one line or statement of the high-level source code.
        </li>
        <li>
         It analyzes that line and translates it into the corresponding machine code instructions.
        </li>
        <li>
         It immediately executes those machine code instructions.
        </li>
        <li>
         It then moves to the next line of the source code and repeats the process.
        </li>
       </ol>
       <p>
        So, unlike a compiler which creates a separate executable file, the interpreter acts as a runtime environment that processes the source code on-the-fly. The user experiences a direct execution model because there is no separate compilation step.
       </p>
      </article>
     </section>
     <section id="operating-systems-overview">
      <h3>
       g. Operating Systems Overview
      </h3>
      <article>
       <h4>
        1. What is an operating system? Describe objectives and functions of operating system.
       </h4>
       <p>
        An
        <strong>
         Operating System (OS)
        </strong>
        is a system software that acts as an intermediary between the computer user and the computer hardware. It manages all the hardware and software resources of the system.
       </p>
       <h5>
        Objectives:
       </h5>
       <ol>
        <li>
         <strong>
          Convenience:
         </strong>
         To make the computer system easier and more convenient for the user to use.
        </li>
        <li>
         <strong>
          Efficiency:
         </strong>
         To manage the computer's resources (CPU, memory, I/O devices) in an efficient manner.
        </li>
        <li>
         <strong>
          Abstraction:
         </strong>
         To hide the complex details of the hardware from the user and application programs.
        </li>
       </ol>
       <h5>
        Functions:
       </h5>
       <ol>
        <li>
         <strong>
          Process Management:
         </strong>
         Manages the execution of programs (processes), including creating, deleting, scheduling, and synchronizing them.
        </li>
        <li>
         <strong>
          Memory Management:
         </strong>
         Allocates and deallocates memory space to programs as needed, and keeps track of memory usage.
        </li>
        <li>
         <strong>
          File System Management:
         </strong>
         Organizes files and directories on storage devices, and controls access to them.
        </li>
        <li>
         <strong>
          Device Management:
         </strong>
         Manages all I/O devices through their respective drivers, handling communication between the devices and the system.
        </li>
        <li>
         <strong>
          Security:
         </strong>
         Provides protection for system resources against unauthorized access.
        </li>
        <li>
         <strong>
          User Interface:
         </strong>
         Provides a way for the user to interact with the computer, either through a Command-Line Interface (CLI) or a Graphical User Interface (GUI).
        </li>
       </ol>
      </article>
      <article>
       <h4>
        2. Write short notes on the following: i) Microsoft Windows OS and ii) Linux OS.
       </h4>
       <h5>
        i) Microsoft Windows OS:
       </h5>
       <p>
        Microsoft Windows is a family of proprietary graphical operating systems developed and marketed by Microsoft. It is the most widely used operating system for desktop and laptop computers. Key features include its Graphical User Interface (GUI), which uses windows, icons, and menus, and its broad hardware and software compatibility ("plug and play"). It supports a vast ecosystem of applications, from productivity software to games. Windows is known for its user-friendliness but is a closed-source system, meaning its source code is not publicly available.
       </p>
       <h5>
        ii) Linux OS:
       </h5>
       <p>
        Linux is a family of open-source Unix-like operating systems based on the Linux kernel. It is developed collaboratively by a global community of programmers. Linux is known for its stability, security, and flexibility. It is distributed in various forms called "distributions" or "distros" (e.g., Ubuntu, Fedora, Debian), which bundle the kernel with system software and application packages. Linux dominates the server, supercomputer, and mobile (via Android) markets and is a popular choice for developers and technical users due to its powerful command-line interface and open-source nature.
       </p>
      </article>
      <article>
       <h4>
        3. Write short notes on the following operating systems: i) Microsoft Windows OS ii) MS-DOS.
       </h4>
       <h5>
        i) Microsoft Windows OS:
       </h5>
       <p>
        (See answer to question 2.i above)
       </p>
       <h5>
        ii) MS-DOS (Microsoft Disk Operating System):
       </h5>
       <p>
        MS-DOS was a dominant operating system for personal computers during the 1980s and early 1990s. It is a non-graphical, command-line-based operating system. Users interact with the system by typing commands at a prompt. It is a single-tasking, single-user OS, meaning it can only run one program and serve one user at a time. MS-DOS has a simple architecture and provides basic functions for file management and program execution. While now obsolete as a standalone OS, its command-line interface principles live on in the Windows Command Prompt.
       </p>
      </article>
      <article>
       <h4>
        4. Why is LINUX preferable? Give some reasons.
       </h4>
       <p>
        Linux is preferable in many scenarios for several key reasons:
       </p>
       <ol>
        <li>
         <strong>
          Open Source:
         </strong>
         Its source code is freely available for anyone to view, modify, and distribute. This fosters transparency, collaboration, and rapid innovation.
        </li>
        <li>
         <strong>
          Cost:
         </strong>
         Most Linux distributions and the software available for them are free of charge, making it a highly cost-effective solution.
        </li>
        <li>
         <strong>
          Security:
         </strong>
         The Linux architecture, with its robust user privilege model, is inherently more secure than many other operating systems. The open-source nature also means that vulnerabilities are often found and patched very quickly by the community.
        </li>
        <li>
         <strong>
          Stability and Reliability:
         </strong>
         Linux is renowned for its stability. It can run for years without needing a reboot, which is why it is the dominant OS for servers and critical infrastructure.
        </li>
        <li>
         <strong>
          Flexibility and Customization:
         </strong>
         Users can customize almost every aspect of the operating system, from the graphical interface to the kernel itself, to suit their specific needs.
        </li>
        <li>
         <strong>
          Performance:
         </strong>
         Linux is generally lightweight and efficient, often providing better performance than other operating systems on the same hardware, especially on older machines.
        </li>
       </ol>
      </article>
      <article>
       <h4>
        5. What are the advantages and disadvantages of MAC operating system?
       </h4>
       <p>
        macOS (formerly OS X) is the proprietary operating system developed by Apple Inc. for its Macintosh line of computers.
       </p>
       <h5>
        Advantages:
       </h5>
       <ol>
        <li>
         <strong>
          User Interface and Ease of Use:
         </strong>
         macOS is widely praised for its clean, intuitive, and aesthetically pleasing graphical user interface (Aqua), which provides a consistent and user-friendly experience.
        </li>
        <li>
         <strong>
          Ecosystem Integration:
         </strong>
         It offers seamless integration with other Apple devices like the iPhone, iPad, and Apple Watch through features like Handoff, AirDrop, and iCloud.
        </li>
        <li>
         <strong>
          Security:
         </strong>
         It is built on a stable and secure Unix-like foundation (BSD) and is generally considered less prone to malware and viruses compared to Windows, partly due to its smaller market share.
        </li>
        <li>
         <strong>
          Software and Hardware Optimization:
         </strong>
         Since Apple controls both the hardware and the software, macOS is highly optimized to run efficiently on Mac hardware, leading to excellent performance and battery life.
        </li>
        <li>
         <strong>
          Creative Professional Software:
         </strong>
         It is the preferred platform for many creative professionals due to the availability and performance of high-quality software for video editing, graphic design, and music production (e.g., Final Cut Pro, Logic Pro).
        </li>
       </ol>
       <h5>
        Disadvantages:
       </h5>
       <ol>
        <li>
         <strong>
          Cost and Hardware Exclusivity:
         </strong>
         macOS only runs on Apple's expensive Mac hardware. It cannot be legally installed on non-Apple PCs.
        </li>
        <li>
         <strong>
          Limited Hardware Customization:
         </strong>
         Unlike PCs, Macs offer very limited options for hardware upgrades and customization.
        </li>
        <li>
         <strong>
          Smaller Software Library:
         </strong>
         While it has all major applications, its overall software library, especially for specialized business software and games, is smaller than that of Windows.
        </li>
        <li>
         <strong>
          Less Gaming Support:
         </strong>
         The platform is generally not prioritized by game developers, leading to fewer available titles and often poorer performance compared to Windows.
        </li>
       </ol>
      </article>
     </section>
    </section>
   </main>
  </div>
  <script src="../script.js">
  </script>
 </body>
</html>
